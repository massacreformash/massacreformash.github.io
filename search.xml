<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[使用`presentViewController`方法弹出模态控制器 并进行自定义操作(二)]]></title>
      <url>http://yoursite.com/2016/08/14/%E4%BD%BF%E7%94%A8%60presentViewController%60%E6%96%B9%E6%B3%95%E5%BC%B9%E5%87%BA%E6%A8%A1%E6%80%81%E6%8E%A7%E5%88%B6%E5%99%A8%20%E5%B9%B6%E8%BF%9B%E8%A1%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E6%93%8D%E4%BD%9C(%E4%BA%8C)/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>前一篇文章实现了从初始控制器中通过点击操作弹出<code>模态控制器</code>的操作, 并进行了一系列在弹出过程中的自定义效果</li>
<li>这篇文章将继续之前的讨论, 完成之后要<code>dismiss</code>掉<code>模态控制器</code>的一系列方法的实现过程<blockquote>
<p>所谓<code>dismiss</code>, 就是让<code>模态视图</code>从屏幕上消失的操作</p>
</blockquote>
</li>
</ul>
<h2 id="UIKit在dismiss过程中都干了啥"><a href="#UIKit在dismiss过程中都干了啥" class="headerlink" title="UIKit在dismiss过程中都干了啥"></a><code>UIKit</code>在<code>dismiss</code>过程中都干了啥</h2><ul>
<li>依旧是翻译官方文档中关于<code>UIKit</code>在<code>dismiss</code>过程中的调用过程</li>
</ul>
<blockquote>
<ol>
<li>从当前可见的<code>viewController</code>中取到之前程序员自定义的<code>presentationController</code></li>
<li>如果存在动画对象或者交互式动画对象的话, 就向过渡代理请求该对象</li>
<li><strong>调用<code>presentationController</code>中的<code>dismissalTransitionWillBegin</code>方法</strong><ul>
<li>在该方法中, 程序员可以添加自定义的 view 到视图的层级结构中, 并对这些自定义的 view 配置动画</li>
</ul>
</li>
<li>从自定义的<code>presentationController</code>取到已经弹出的<code>presentedView</code></li>
<li><strong>执行<code>dismiss</code>过程中的跳转动画</strong><ul>
<li>跳转过渡动画包括一个主动画(由动画对象<code>animator objects</code>创建)和若干随主动画一起执行的自定义动画效果. 如果想了解更多有关过渡动画的信息, 可以参阅<a href="https://developer.apple.com/library/ios/featuredarticles/ViewControllerPGforiPhoneOS/CustomizingtheTransitionAnimations.html#//apple_ref/doc/uid/TP40007457-CH16-SW2" target="_blank" rel="external">The Transition Animation Sequence 文档</a></li>
<li>在动画的执行过程中, <code>UIKit</code>会调用我们自定义的<code>presentationController</code>中的<code>containerViewWillLayoutSubviews</code>方法和<code>containerViewDidLayoutSubviews</code>方法, 程序员可以在这两个方法中移除之前自定义的约束(应该是 view 吧?)</li>
</ul>
</li>
<li>在动画结束时, 会调用<code>dismissalTransitionDidEnd:</code>方法</li>
</ol>
</blockquote>
<h2 id="实现dismiss模态控制器的具体步骤"><a href="#实现dismiss模态控制器的具体步骤" class="headerlink" title="实现dismiss模态控制器的具体步骤"></a>实现<code>dismiss</code>模态控制器的具体步骤</h2><blockquote>
<ul>
<li>当模态控制器被<code>dismiss</code>时, 可以使用<code>dismissalTransitionDidEnd:</code>方法来从视图层级结构中移除自定义的 view</li>
<li>而如果想要在<code>dismiss</code>的过程中执行一些消失的动画效果, 也可以在<code>dismissalTransitionDidEnd:</code>中进行自定义</li>
</ul>
</blockquote>
<h3 id="开始dismiss过程调用的方法"><a href="#开始dismiss过程调用的方法" class="headerlink" title="开始dismiss过程调用的方法"></a>开始<code>dismiss</code>过程调用的方法</h3><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">dismissalTransitionWillBegin</span> &#123;</div><div class="line">    <span class="comment">//将暗色视图渐出</span></div><div class="line">    <span class="selector-tag">if</span>([[self presentedViewController] transitionCoordinator]) &#123;</div><div class="line">        <span class="selector-attr">[[[self presentedViewController]</span> <span class="selector-tag">transitionCoordinator</span>]</div><div class="line">         <span class="selector-tag">animateAlongsideTransition</span>:^(id&lt;UIViewControllerTransitionCoordinatorContext&gt;</div><div class="line">                                      context) &#123;</div><div class="line">             <span class="selector-attr">[[self dimmingView]</span> <span class="selector-tag">setAlpha</span><span class="selector-pseudo">:0.0</span>];</div><div class="line">         &#125; <span class="attribute">completion</span>:nil];</div><div class="line">    &#125;</div><div class="line">    <span class="selector-tag">else</span> &#123;</div><div class="line">        <span class="selector-attr">[[self dimmingView]</span> <span class="selector-tag">setAlpha</span><span class="selector-pseudo">:0.0</span>];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="dismiss过程结束后调用的方法"><a href="#dismiss过程结束后调用的方法" class="headerlink" title="dismiss过程结束后调用的方法"></a><code>dismiss</code>过程结束后调用的方法</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)dismissalTransitionDidEnd:(<span class="built_in">BOOL</span>)completed &#123;</div><div class="line">    <span class="comment">//如果 dismiss 过程成功结束, 则将暗色视图从层级结构中移除</span></div><div class="line">    <span class="keyword">if</span> (completed)</div><div class="line">        [<span class="keyword">self</span>.dimmingView removeFromSuperview];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>运行测试<br>可以看到, 在<code>dismiss</code>的过程中, 暗色的背景视图由深至浅消失不见了<br><img src="http://d.pr/i/1iQMa+" alt="测试"></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[使用`presentViewController`方法弹出模态控制器 并进行自定义操作(一)]]></title>
      <url>http://yoursite.com/2016/08/10/%E4%BD%BF%E7%94%A8%60presentViewController%60%E6%96%B9%E6%B3%95%E5%BC%B9%E5%87%BA%E6%A8%A1%E6%80%81%E6%8E%A7%E5%88%B6%E5%99%A8%20%E5%B9%B6%E8%BF%9B%E8%A1%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E6%93%8D%E4%BD%9C(%E4%B8%80)/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>自己在做项目的时候, 需要实现一个自定义弹窗的效果, 同时在上面实现很多子功能, 此时如果用自定义的View来做的话就显得有些力不从心了, 必须想到另一种方法实现</li>
<li>更合适的实现方式应该就是使用<code>presentViewController: animated: completion:</code>方法弹出模态控制器来做, 但如果不进行自定义的话, 弹出的控制器永远都是和屏幕一样大, 因此需要进行自定义</li>
<li>比较坑的是, 网上很多自定义present控制器的方法都是<code>iOS 8.0</code>之前的实现步骤了, 要找到一个能完美解决问题的教程很难, 不得已只好翻阅苹果官方的 develop 文档, 通读之后顺利解决问题, 下面就把自己实现的过程做一下梳理</li>
</ul>
<blockquote>
<ul>
<li>官方文档: <code>Creating Custom Presentations</code></li>
<li><a href="https://developer.apple.com/library/prerelease/content/featuredarticles/ViewControllerPGforiPhoneOS/DefiningCustomPresentations.html#//apple_ref/doc/uid/TP40007457-CH25-SW1" target="_blank" rel="external">文档地址</a></li>
<li>如果打不开的话, 可以直接在<a href="https://developer.apple.com/" target="_blank" rel="external">https://developer.apple.com/</a>的搜索框中搜索<code>Creating Custom Presentations</code>这篇文档</li>
</ul>
</blockquote>
<h2 id="实现自定义模态控制器的具体步骤"><a href="#实现自定义模态控制器的具体步骤" class="headerlink" title="实现自定义模态控制器的具体步骤"></a>实现自定义模态控制器的具体步骤</h2><h3 id="在初始控制器需要完成的步骤"><a href="#在初始控制器需要完成的步骤" class="headerlink" title="在初始控制器需要完成的步骤"></a>在初始控制器需要完成的步骤</h3><blockquote>
<p>在本例中, 假设在程序启动后, 点击屏幕就会弹出<code>模态控制器</code>, 所以下面的逻辑代码均在<code>touchesBegan: withEvent:</code>中实现</p>
</blockquote>
<ul>
<li>在准备弹出<code>模态控制器</code>的初始<code>viewController</code>中(实际上这个控制器应当被称为<code>presentingViewController</code>, 下同)初始化<code>模态控制器</code>(同样的, 在方法中, 这个要弹出来的<code>模态控制器</code>被称为<code>presentedViewController</code>, 下同)</li>
</ul>
<blockquote>
<p>事先需要自定义一个新类作为要初始化的<code>presentedViewController</code>, 并继承自<code>UIViewController</code>, 本例中自定义了一个名为</p>
<ul>
<li><strong><code>MusicViewController</code></strong></li>
</ul>
<p>的类作为要弹出的<code>presentedViewController</code>的类</p>
</blockquote>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#import</span> <span class="string">"MusicViewController.h"</span></div></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">-(<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event&#123;</div><div class="line">  </div><div class="line">    <span class="comment">//1.</span></div><div class="line">    MusicViewController *vc = [[MusicViewController alloc] init];</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>设置<code>presentedViewController</code>的<code>modalPresentationStyle</code>属性为<code>UIModalPresentationCustom</code></li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">-(<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event&#123;</div><div class="line">    </div><div class="line">    <span class="comment">//1.</span></div><div class="line">    MusicViewController *vc = [[MusicViewController alloc] init];</div><div class="line">    </div><div class="line">    <span class="comment">//2.</span></div><div class="line">    vc.modalPresentationStyle = <span class="built_in">UIModalPresentationCustom</span>;</div><div class="line">   </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>初始化<code>presentedViewController</code>的代理<blockquote>
<ul>
<li>这个代理是<strong>重中之重</strong>, 是实现自定义<code>presentedViewController</code>的最重要的组成部分, 下面的步骤中会<strong>重点分析</strong></li>
</ul>
<p>暂时需要知道的是, 这个代理需要自定义一个遵守<code>&lt;UIViewControllerTransitioningDelegate&gt;</code>协议的类, 并且继承自<code>UIPresentationController</code>类. 本例中自定义了一个名为</p>
<ul>
<li><strong><code>MusicAnimator</code></strong></li>
</ul>
<p>的类作为要弹出的<code>presentedViewController</code>的代理</p>
</blockquote>
</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#import</span> <span class="string">"MusicAnimator.h"</span></div></pre></td></tr></table></figure>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="variable">@interface</span> ViewController ()</div><div class="line"><span class="variable">@property</span> (nonatomic, strong) MusicAnimator *animotor;</div><div class="line"><span class="variable">@end</span></div></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">-(<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event&#123;</div><div class="line">    </div><div class="line">    <span class="comment">//1.</span></div><div class="line">    MusicViewController *vc = [[MusicViewController alloc] init];</div><div class="line">    </div><div class="line">    <span class="comment">//2.</span></div><div class="line">    vc.modalPresentationStyle = <span class="built_in">UIModalPresentationCustom</span>;</div><div class="line">    </div><div class="line">    <span class="comment">//3.</span></div><div class="line">    <span class="keyword">self</span>.animotor = [[MusicAnimator alloc] init];</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>设置<code>presentedViewController</code>的代理为刚才初始化好的代理对象</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">-(<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event&#123;</div><div class="line">    </div><div class="line">    <span class="comment">//1.</span></div><div class="line">    MusicViewController *vc = [[MusicViewController alloc] init];</div><div class="line">    </div><div class="line">    <span class="comment">//2.</span></div><div class="line">    vc.modalPresentationStyle = <span class="built_in">UIModalPresentationCustom</span>;</div><div class="line">    </div><div class="line">    <span class="comment">//3.</span></div><div class="line">    <span class="keyword">self</span>.animotor = [[MusicAnimator alloc] init];</div><div class="line">    </div><div class="line">    <span class="comment">//4.</span></div><div class="line">    vc.transitioningDelegate = <span class="keyword">self</span>.animotor;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>调用<code>presentViewController: animated: completion:</code>方法弹出模态控制器</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">-(<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event&#123;</div><div class="line">    </div><div class="line">    <span class="comment">//1.</span></div><div class="line">    MusicViewController *vc = [[MusicViewController alloc] init];</div><div class="line">    </div><div class="line">    <span class="comment">//2.</span></div><div class="line">    vc.modalPresentationStyle = <span class="built_in">UIModalPresentationCustom</span>;</div><div class="line">    </div><div class="line">    <span class="comment">//3.</span></div><div class="line">    <span class="keyword">self</span>.animotor = [[MusicAnimator alloc] init];</div><div class="line">    </div><div class="line">    <span class="comment">//4.</span></div><div class="line">    vc.transitioningDelegate = <span class="keyword">self</span>.animotor;</div><div class="line">    </div><div class="line">    <span class="comment">//5.</span></div><div class="line">    [<span class="keyword">self</span> presentViewController:vc animated:<span class="literal">YES</span> completion:^&#123;</div><div class="line">    &#125;];</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="自定义presentedViewController的代理"><a href="#自定义presentedViewController的代理" class="headerlink" title="自定义presentedViewController的代理"></a>自定义<code>presentedViewController</code>的代理</h3><blockquote>
<p>这个代理集成了几乎所有弹出<code>模态</code>的自定义操作, 在<a href="https://developer.apple.com/library/prerelease/content/featuredarticles/ViewControllerPGforiPhoneOS/DefiningCustomPresentations.html#//apple_ref/doc/uid/TP40007457-CH25-SW1" target="_blank" rel="external">官方文档</a>中, 苹果为我们详细说明了 <code>UIKit</code> 是如何通过这个代理完成弹出<code>模态</code>的操作: </p>
<ol>
<li>调用<strong>代理</strong>的 <code>presentationControllerForPresentedViewController:presentingViewController:sourceViewController:</code> 方法来检索自定义的 <code>presentationController</code><ul>
<li>(实际上这里的<strong>代理</strong>就是 <code>presentedViewController</code> 的代理, 也就是本例中继承自 <code>UIPresentationController</code> 类的 <code>MusicAnimator</code> 对象)</li>
</ul>
</li>
<li>如果<strong>代理</strong>中存在动画和交互式动画对象，则调用它们</li>
<li><strong>调用 <code>presentationController</code> 的 <code>presentationTransitionWillBegin</code> 方法</strong><ul>
<li>程序员在对于该方法的实现中, 可以添加自定义 <code>view</code> 到视图层级结构中, 并配置这些 <code>view</code> 的动画。</li>
</ul>
</li>
<li><strong>从 <code>presentationController</code> 获取 <code>presentedView</code></strong><ul>
<li>该方法返回的 <code>view</code> 由动画对象移动到最终确定的位置. 正常情况下，该方法返回 <code>presentedViewController</code> 的根视图.</li>
<li>如果需要的话, 程序员自定义的 <code>presentationController</code> 可以用自定义背景视图替换该视图.<br>如果指定了一个不同的视图，则必须将 <code>presentedViewController</code> 的根视图添加到自己的视图层级结构中</li>
</ul>
</li>
<li><strong>执行过渡动画</strong><ul>
<li>过渡动画包括动画对象创建的主要动画, 和其他由程序员配置的与主动画一起运行的动画。<br>关于过渡动画的更多信息，参见<a href="https://developer.apple.com/library/prerelease/content/featuredarticles/ViewControllerPGforiPhoneOS/CustomizingtheTransitionAnimations.html#//apple_ref/doc/uid/TP40007457-CH16-SW2" target="_blank" rel="external">The Transition Animation Sequence</a></li>
<li>在动画过程中，<code>UIKit</code> 调用自定义的 <code>presentationController</code> 的 <code>containerViewWillLayoutSubviews</code> 和 <code>containerViewDidLayoutSubviews</code> 方法，这样你可以根据需要调整自定义视图的布局。</li>
</ul>
</li>
<li>当过渡动画完成时，会调用 <code>presentationTransitionDidEnd:</code> 方法</li>
</ol>
</blockquote>
<h4 id="显示自定义的-presentedViewController"><a href="#显示自定义的-presentedViewController" class="headerlink" title="显示自定义的 presentedViewController"></a>显示自定义的 <code>presentedViewController</code></h4><blockquote>
<p>在此之前, 由于模态控制器还没有背景色, 所以先给其设置一个背景色, 以便观察, 这里设置的是<strong>黄色</strong></p>
</blockquote>
<ul>
<li>最首要的任务, 是先要能够将一个完整的模态控制器显示出来, 那么在代理控制器中, 首先要实现下面这个方法</li>
<li>该方法就是上面<code>步骤1</code>中, <code>UIKit</code> 用来检索自定义的 <code>presentationController</code>的方法</li>
</ul>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="variable">@implementation</span> MusicAnimator</div><div class="line"></div><div class="line">- (UIPresentationController *)<span class="attribute">presentationControllerForPresentedViewController</span>:(UIViewController *)presented</div><div class="line">                                                      <span class="attribute">presentingViewController</span>:(UIViewController *)presenting</div><div class="line">                                                          <span class="attribute">sourceViewController</span>:(UIViewController *)source &#123;</div><div class="line">    </div><div class="line">    MusicAnimator* myPresentation = <span class="selector-attr">[[MusicAnimator alloc]</span></div><div class="line">                                     <span class="selector-tag">initWithPresentedViewController</span><span class="selector-pseudo">:presented</span> <span class="selector-tag">presentingViewController</span><span class="selector-pseudo">:presenting</span>];</div><div class="line">    </div><div class="line">    return myPresentation;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="variable">@end</span></div></pre></td></tr></table></figure>
<blockquote>
<p>运行测试<br>点击屏幕后, 会弹出如下界面<br><img src="http://d.pr/i/kF4H+" alt="测试"></p>
</blockquote>
<h4 id="修改-presentedViewController-的frame大小"><a href="#修改-presentedViewController-的frame大小" class="headerlink" title="修改 presentedViewController 的frame大小"></a>修改 <code>presentedViewController</code> 的<code>frame</code>大小</h4><ul>
<li>下面的方法, 描述了如何自定义<code>presentedViewController</code>的<code>frame</code></li>
</ul>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">- (CGRect)frameOfPresentedViewInContainerView &#123;</div><div class="line">    <span class="comment">//初始化模态控制器的 frame</span></div><div class="line">    CGRect presentedViewFrame = CGRectZero;</div><div class="line">    <span class="comment">//获得默认的容器视图的大小(默认为与屏幕一样大)</span></div><div class="line">    CGRect containerBounds = [[self containerView] bounds];</div><div class="line">    </div><div class="line">    <span class="comment">//设置模态控制器的 size 为宽高都是屏幕大小的一半, 并向下取整</span></div><div class="line">    presentedViewFrame.<span class="built_in">size</span> = CGSizeMake(floorf(containerBounds.<span class="built_in">size</span>.<span class="built_in">width</span> * <span class="number">0.5</span>),</div><div class="line">                                         floorf(containerBounds.<span class="built_in">size</span>.<span class="built_in">height</span> * <span class="number">0.5</span>));</div><div class="line">    <span class="comment">//设置设置模态控制器的初始位置</span></div><div class="line">    presentedViewFrame.origin.x = (containerBounds.<span class="built_in">size</span>.<span class="built_in">width</span> -</div><div class="line">    presentedViewFrame.<span class="built_in">size</span>.<span class="built_in">width</span>) * <span class="number">0.5</span>;</div><div class="line">    presentedViewFrame.origin.y = (containerBounds.<span class="built_in">size</span>.<span class="built_in">height</span> -</div><div class="line">    presentedViewFrame.<span class="built_in">size</span>.<span class="built_in">height</span>) * <span class="number">0.5</span>;</div><div class="line">    <span class="comment">//返回自定义之后的模态控制器的 frame</span></div><div class="line">    <span class="built_in">return</span> presentedViewFrame;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>运行测试<br>点击屏幕后, 会弹出如下界面<br><img src="http://d.pr/i/F6NU+" alt="测试"></p>
</blockquote>
<h4 id="管理自定义View并添加动画"><a href="#管理自定义View并添加动画" class="headerlink" title="管理自定义View并添加动画"></a>管理自定义<code>View</code>并添加动画</h4><ul>
<li>文档描述如下(自己翻译的, 些许不准, 请指正😊)</li>
</ul>
<blockquote>
<ul>
<li>自定义<code>presentation</code>效果通常包括”添加自定义 View “到要<code>presented</code>的控制器中, 程序员可以通过这种方式实现简单的视觉效果, 或者添加一些实际的动作到<code>presentation</code>过程中.</li>
<li>举例来说, 可以添加一个包含着手势对象的<code>backgroundView</code>到需要<code>presented</code>的控制器的<code>bounds</code>之外, 来追踪一些特定的手势操作(我自己注: 如点击<code>presented</code>的控制器外可以将其 dismiss 掉之类的操作)</li>
<li>在<code>presentation</code>的过程中, 所有<code>创建</code>和<code>管理</code>自定义 View 的操作, 都是由用户自定义的<code>presentationController</code>负责的.</li>
<li>通常情况下, 创建自定义 View 的操作, 都是在初始化<code>presentationController</code>的方法中完成的. 下面的例子展示了一个初始化自定义 View , 并对其进行一些简单配置的过程</li>
</ul>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//初始化presentationController的方法</span></div><div class="line">- (<span class="keyword">instancetype</span>)initWithPresentedViewController:(<span class="built_in">UIViewController</span> *)presentedViewController</div><div class="line">                       presentingViewController:(<span class="built_in">UIViewController</span> *)presentingViewController &#123;</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> initWithPresentedViewController:presentedViewController</div><div class="line">                         presentingViewController:presentingViewController];</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">self</span>) &#123;</div><div class="line">        <span class="comment">// 初始化一个暗色视图, 并设置初始外观</span></div><div class="line">        <span class="keyword">self</span>.dimmingView = [[<span class="built_in">UIView</span> alloc] init];</div><div class="line">        [<span class="keyword">self</span>.dimmingView setBackgroundColor:[<span class="built_in">UIColor</span> colorWithWhite:<span class="number">0.0</span> alpha:<span class="number">0.4</span>]];</div><div class="line">        [<span class="keyword">self</span>.dimmingView setAlpha:<span class="number">0.0</span>];</div><div class="line">        <span class="comment">//注意! 这里并没有将初始化的自定义 View 添加上去!</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>继续文档描述</li>
</ul>
<blockquote>
<ul>
<li>想要将自定义 View 渲染到屏幕上并开始做动画的话, 需要调用<code>presentationTransitionWillBegin</code>方法. 在该方法中, 可以配置自定义的 View 的属性并将其添加到<code>presentationController</code>的<code>containerView</code>中</li>
<li>如果想要做动画, 则可以选用<code>presentedViewController</code>或者<code>presentingViewController</code>的<code>transitionCoordinator</code>来创建动画.</li>
<li>不要在这个方法中修改有关于<code>presentedViewController</code>之上的任何 View (也就是说, 这个方法只用来设置自定义 View 和动画效果, 而不是设置放置在模态控制器上的view的)</li>
<li><code>transitionCoordinator</code>这个动画对象, 就是负责将<code>presentedViewController</code>渲染到之前我们在<code>frameOfPresentedViewInContainerView</code>方法中返回的<code>frame</code>的位置上的对象</li>
</ul>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)presentationTransitionWillBegin &#123;</div><div class="line">    <span class="comment">//取到 presentationController 的容器视图</span></div><div class="line">    <span class="built_in">UIView</span>* containerView = [<span class="keyword">self</span> containerView];</div><div class="line">    <span class="comment">//取到准备跳转的 presentedViewController</span></div><div class="line">    <span class="built_in">UIViewController</span>* presentedViewController = [<span class="keyword">self</span> presentedViewController];</div><div class="line">    </div><div class="line">    <span class="comment">//设置暗色视图的 frame 为 containerView 的大小(也就是屏幕的大小)</span></div><div class="line">    <span class="comment">////设置暗色视图的 alpha 值 为0</span></div><div class="line">    [[<span class="keyword">self</span> dimmingView] setFrame:[containerView bounds]];</div><div class="line">    [[<span class="keyword">self</span> dimmingView] setAlpha:<span class="number">0.0</span>];</div><div class="line">    </div><div class="line">    <span class="comment">//将暗色视图插入到 containerView 的所有视图的最下方</span></div><div class="line">    [containerView insertSubview:[<span class="keyword">self</span> dimmingView] atIndex:<span class="number">0</span>];</div><div class="line">    </div><div class="line">    <span class="comment">//设置暗色视图的渐入效果</span></div><div class="line">    <span class="keyword">if</span>([presentedViewController transitionCoordinator]) &#123;</div><div class="line">        [[presentedViewController transitionCoordinator]</div><div class="line">         animateAlongsideTransition:^(<span class="keyword">id</span>&lt;<span class="built_in">UIViewControllerTransitionCoordinatorContext</span>&gt;</div><div class="line">                                      context) &#123;</div><div class="line">             <span class="comment">//渐入动画</span></div><div class="line">             [[<span class="keyword">self</span> dimmingView] setAlpha:<span class="number">1.0</span>];</div><div class="line">         &#125; completion:<span class="literal">nil</span>];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        [[<span class="keyword">self</span> dimmingView] setAlpha:<span class="number">1.0</span>];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>运行测试<br>点击屏幕后, 会弹出如下界面, 可以看到在弹出的黄色模态控制器后, 有一个暗色的背景由浅入深做了动画<br><img src="http://d.pr/i/Y6cs+" alt="测试"></p>
</blockquote>
<h4 id="弹出模态完成后的操作"><a href="#弹出模态完成后的操作" class="headerlink" title="弹出模态完成后的操作"></a>弹出模态完成后的操作</h4><ul>
<li>文档描述如下(自己翻译的, 些许不准, 请指正😊)</li>
</ul>
<blockquote>
<ul>
<li>如果用户在跳转过程中取消了跳转操作(也就是跳转未完成), 那么程序员可以在<code>presentation</code>过程的最后, 使用<code>presentationTransitionDidEnd:</code>方法处理一些由于取消操作导致的必要的清理工作</li>
<li>如果一些所需的门槛条件没有满足的话, 那么交互式动画对象可能会取消跳转过程, 此时<code>presentationTransitionDidEnd:</code>方法中的<code>completed</code>参数会被设置为<code>NO</code></li>
<li>一旦跳转被取消, 那么程序员需要移除所有在跳转过程一开始被添加的自定义view, (并且返回之前配置的<code>View</code> &lt;– 这一步应该不是必须的)</li>
</ul>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)presentationTransitionDidEnd:(<span class="built_in">BOOL</span>)completed &#123;</div><div class="line">    <span class="comment">//如果跳转过程被取消, 则将暗色视图移除</span></div><div class="line">    <span class="keyword">if</span> (!completed)</div><div class="line">        [<span class="keyword">self</span>.dimmingView removeFromSuperview];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><br><br></p>
<ul>
<li>这篇文章已经实现了如何弹出一个自定义<code>frame</code>的模态控制器, 并在其跳转过程中实现一些自定义的<code>view</code>和动画效果</li>
<li>下一篇文章, 我将再把文档中如何<code>dismiss</code>掉这个控制器的方法进行一系列实现</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[iOS多线程技术的几种实现方案(一) pthread]]></title>
      <url>http://yoursite.com/2016/08/05/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%8A%80%E6%9C%AF%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88(%E4%B8%80)%20pthread/</url>
      <content type="html"><![CDATA[<h2 id="iOS中多线程的实现方案"><a href="#iOS中多线程的实现方案" class="headerlink" title="iOS中多线程的实现方案"></a>iOS中多线程的实现方案</h2><table>
<thead>
<tr>
<th>方案</th>
<th style="text-align:left">简介</th>
<th style="text-align:center">语言</th>
<th style="text-align:center">线程生命周期</th>
<th style="text-align:right">使用频率</th>
</tr>
</thead>
<tbody>
<tr>
<td>pthread</td>
<td style="text-align:left"><li>一套通用的多线程API</li><li>适用于 Unix / Linux / Windows 等系统</li><li>跨平台\可移植</li><li>使用难度大</li></td>
<td style="text-align:center">C</td>
<td style="text-align:center">程序员管理</td>
<td style="text-align:right">几乎不用</td>
</tr>
<tr>
<td>NSThread</td>
<td style="text-align:left"><li>使用更加面向对象</li><li>简单易用，可直接操作线程对象</li></td>
<td style="text-align:center">OC</td>
<td style="text-align:center">程序员管理</td>
<td style="text-align:right">偶尔使用</td>
</tr>
<tr>
<td>GCD</td>
<td style="text-align:left"><li>旨在替代NSThread等线程技术</li><li>充分利用设备的多核</li></td>
<td style="text-align:center">C</td>
<td style="text-align:center">自动管理</td>
<td style="text-align:right">经常使用</td>
</tr>
<tr>
<td>NSOperation</td>
<td style="text-align:left"><li>基于GCD（底层是GCD）</li><li>比GCD多了一些更简单实用的功能</li><li>使用更加面向对象</li></td>
<td style="text-align:center">OC</td>
<td style="text-align:center">自动管理</td>
<td style="text-align:right">经常使用</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>插播一段碎碎念</strong></p>
<ul>
<li><p>作为markdown语法, 生成表格一直是比较蛋疼的事情, 没办法换行, 更别提是使用无序或者有序列表了, 不过好歹markdown还保留了HTML最基本的用法, 能够供我们调用</p>
</li>
<li><p>那么想要在表格中简单的换行怎么做呢? 很简单, 只需要将表格中想要换行的段落前面加上<code>&lt;br&gt;</code>, 后面加上<code>&lt;/br&gt;</code>即可</p>
</li>
<li>而想要插入有序列表, 只需要在表格中想要换行的的段落前面加上<code>&lt;li&gt;</code>, 后面加上<code>&lt;/li&gt;</code>即可</li>
</ul>
</blockquote>
<h2 id="pthread"><a href="#pthread" class="headerlink" title="pthread"></a>pthread</h2><ul>
<li><code>pthread</code>是<code>POSIX</code>多线程开发框架, 由于是跨平台的C语言框架, 在苹果的头文件中并没有详细的注释</li>
<li>要查阅<code>pthread</code>的有关资料, 只能自行在网络上搜索</li>
</ul>
<h3 id="导入头文件"><a href="#导入头文件" class="headerlink" title="导入头文件"></a>导入头文件</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;pthread.h&gt;</span></span></div></pre></td></tr></table></figure>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    <span class="comment">//输出当前线程</span></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"main, %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</div><div class="line">    </div><div class="line">    <span class="comment">//线程标识符, 可以为空</span></div><div class="line">    pthread_t thread = <span class="literal">NULL</span>;</div><div class="line">    <span class="comment">//子线程执行函数时需要传入的参数</span></div><div class="line">    <span class="built_in">NSString</span> *str = <span class="string">@"argu"</span>;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     *  使用pthread创建子线程</div><div class="line">     *</div><div class="line">     *  @param thread 指向线程标识符的指针</div><div class="line">     *  @param NULL   设置线程属性的参数, 可以为空</div><div class="line">     *  @param demo   子线程准备执行的函数</div><div class="line">     *  @param void   准备执行的函数所需要的参数</div><div class="line">     *</div><div class="line">     *  @return 返回值为0代表创建成功, 如错误会显示错误码</div><div class="line">     */</div><div class="line">    <span class="keyword">int</span> result = pthread_create(&amp;thread, <span class="literal">NULL</span>, demo, (__bridge <span class="keyword">void</span> *)(str));</div><div class="line">    </div><div class="line">    <span class="comment">//判断是否创建成功</span></div><div class="line">    <span class="keyword">if</span> (result == <span class="number">0</span>) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"success"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"failed"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> *  准备在子线程中执行的函数</div><div class="line"> */</div><div class="line"><span class="keyword">void</span> *demo(<span class="keyword">void</span> *params) &#123;</div><div class="line">    <span class="comment">//打印当前线程</span></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"demo, %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</div><div class="line">    <span class="comment">//定义函数的参数为 OC 中的 NSString 类型</span></div><div class="line">    <span class="built_in">NSString</span> *str = (__bridge <span class="built_in">NSString</span> *)(params);</div><div class="line">    <span class="comment">//打印参数</span></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"demo, str = %@"</span>, str);</div><div class="line">    <span class="comment">//返回</span></div><div class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol>
<li>在 C 语言中, 没有<code>对象</code>的概念, 对象是通过<code>结构体</code>来实现的(其实 Objective-C 的底层实现中, 对象也是通过 C 的结构体来实现)</li>
<li>通常, 在使用 C 语言的框架中, 对象类型一般以<code>_t</code>/<code>Ref</code>结尾, 声明时不需要使用<code>*</code></li>
<li><strong>C 语言中的<code>void *</code>和 Objective-C 中的<code>id</code>类型是等价的</strong></li>
<li>在混合开发时, 如果在 C 和 Objective-C 之间传递数据, 需要使用<code>__bridge</code>进行桥接, 桥接的目的是为了告诉编译器如何管理内存</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[模拟SDWebImage异步下载图片操作(五) 抽取SDWebImage分类]]></title>
      <url>http://yoursite.com/2016/08/04/%E6%A8%A1%E6%8B%9FSDWebImage%E5%BC%82%E6%AD%A5%E4%B8%8B%E8%BD%BD%E5%9B%BE%E7%89%87%E6%93%8D%E4%BD%9C(%E4%BA%94)%20%E6%8A%BD%E5%8F%96SDWebImage%E5%88%86%E7%B1%BB/</url>
      <content type="html"><![CDATA[<h2 id="a-UIImageView的分类方法"><a href="#a-UIImageView的分类方法" class="headerlink" title="a. UIImageView的分类方法"></a>a. UIImageView的分类方法</h2><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><ul>
<li>通过<code>分类</code>方法简化Web图像加载</li>
<li>使用<code>runtime</code>中<code>关联对象</code>, 对分类中的属性进行关联</li>
</ul>
<h3 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h3><ul>
<li>新建<code>UIImageView</code>的分类<code>UIImageView+WebCache</code></li>
<li>定义分类的对象方法</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">UIImageView</span> (<span class="title">WebCache</span>)</span></div><div class="line"></div><div class="line">-(<span class="keyword">void</span>)_setImageWithURLString:(<span class="built_in">NSString</span> *)URLString placeHolder:(<span class="built_in">UIImage</span> *)placeHolder;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<h4 id="分类方法的初步实现"><a href="#分类方法的初步实现" class="headerlink" title="分类方法的初步实现"></a>分类方法的初步实现</h4><ul>
<li>导入下载管理器的头文件</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#import</span> <span class="string">"DownloadOperationManager.h"</span></div></pre></td></tr></table></figure>
<ul>
<li>实现分类方法</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">-(<span class="keyword">void</span>)_setImageWithURLString:(<span class="built_in">NSString</span> *)URLString placeHolder:(<span class="built_in">UIImage</span> *)placeHolder&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">self</span>.image = placeHolder;</div><div class="line">    </div><div class="line">    [[DownloadOperationManager sharedManager] downloadImageWithURLString:URLString completion:^(<span class="built_in">UIImage</span> *image) &#123;</div><div class="line">        <span class="keyword">self</span>.image = image;</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="修改viewController的代码"><a href="#修改viewController的代码" class="headerlink" title="修改viewController的代码"></a>修改<code>viewController</code>的代码</h4><ul>
<li>导入分类的头文件</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#import</span> <span class="string">"UIImageView+WebCache.h"</span></div></pre></td></tr></table></figure>
<ul>
<li>修改数据源方法</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">-(UITableViewCell *)<span class="string">tableView:</span>(UITableView *)tableView <span class="string">cellForRowAtIndexPath:</span>(NSIndexPath *)indexPath&#123;</div><div class="line">    </div><div class="line">    AppCell *cell = [tableView <span class="string">dequeueReusableCellWithIdentifier:</span>cellID <span class="string">forIndexPath:</span>indexPath];</div><div class="line">    </div><div class="line">    AppInfo *info = self.app_infos[indexPath.row];</div><div class="line">    </div><div class="line">    cell.appName.text = info.name;</div><div class="line">    cell.downCount.text = info.download;</div><div class="line">    <span class="comment">//在这里设置占位图像 用来解决图像闪动的问题</span></div><div class="line">    cell.iconView.image = [UIImage <span class="string">imageNamed:</span>@<span class="string">"user_default"</span>];</div><div class="line">    </div><div class="line">    [cell.iconView <span class="string">_setImageWithURLString:</span>info.icon <span class="string">placeHolder:</span>[UIImage <span class="string">imageNamed:</span>@<span class="string">"user_default"</span>]];</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> cell;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>运行测试<br><img src="http://d.pr/i/1gBG2+" alt="测试"></p>
<ul>
<li>发现快速滚动的时候, cell一旦复用, 会重复创建下载操作, 导致图片错乱</li>
<li>解决方案: 记录此前的<code>URLString</code>, 如果当前cell的<code>URLString</code>发生变化, 则取消之前的下载操作</li>
</ul>
</blockquote>
<h4 id="运行时关联对象的使用"><a href="#运行时关联对象的使用" class="headerlink" title="运行时关联对象的使用"></a>运行时关联对象的使用</h4><ul>
<li>在分类中定义<code>URLString</code>属性</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *URLString;</div></pre></td></tr></table></figure>
<ul>
<li>导入头文件</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></div></pre></td></tr></table></figure>
<blockquote>
<p>此时会得到以下两个警告, 提示我们属性<code>URLString</code>需要进行动态的绑定</p>
<ul>
<li>Property ‘URLString’ requires method ‘URLString’ to be defined - use @dynamic or provide a method implementation in this category</li>
<li>Property ‘URLString’ requires method ‘setURLString:’ to be defined - use @dynamic or provide a method implementation in this category</li>
<li>定义关联对象属性的<code>key</code></li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> *URLStringKey = <span class="string">"kURLStringKey"</span>;</div></pre></td></tr></table></figure>
<ul>
<li>实现属性的<code>getter</code>和<code>setter</code>方法</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">-(<span class="built_in">NSString</span> *)URLString&#123;</div><div class="line">    <span class="keyword">return</span> objc_getAssociatedObject(<span class="keyword">self</span>, URLStringKey);</div><div class="line">&#125;</div><div class="line"></div><div class="line">-(<span class="keyword">void</span>)setURLString:(<span class="built_in">NSString</span> *)URLString&#123;</div><div class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, URLStringKey, URLString, OBJC_ASSOCIATION_COPY_NONATOMIC);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>修改分类中设置图像的方法</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">-(<span class="keyword">void</span>)_setImageWithURLString:(<span class="built_in">NSString</span> *)URLString placeHolder:(<span class="built_in">UIImage</span> *)placeHolder&#123;</div><div class="line">    <span class="comment">//当准备下载的图像的url与此前该cell中准备下载的图像url不等, 且该cell中至少有一个图像正在下载时</span></div><div class="line">    <span class="comment">//取消之前的下载操作(取消操作将在后面实现)</span></div><div class="line">    <span class="keyword">if</span> (![URLString isEqualToString:<span class="keyword">self</span>.URLString] &amp;&amp; <span class="keyword">self</span>.URLString != <span class="literal">nil</span>) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"取消之前的下载操作"</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//使用新的url下载图像, 并记录当前的url</span></div><div class="line">    <span class="keyword">self</span>.URLString = URLString;</div><div class="line">    </div><div class="line">    <span class="comment">//设置占位图像</span></div><div class="line">    <span class="keyword">self</span>.image = placeHolder;</div><div class="line">    </div><div class="line">    [[DownloadOperationManager sharedManager] downloadImageWithURLString:URLString completion:^(<span class="built_in">UIImage</span> *image) &#123;</div><div class="line">        <span class="comment">//下载完成后回调时, 将当前下载操作的url置空</span></div><div class="line">        <span class="comment">//(清除关联属性)</span></div><div class="line">        <span class="keyword">self</span>.URLString = <span class="literal">nil</span>;</div><div class="line">        <span class="comment">//设置下载好的图片</span></div><div class="line">        <span class="keyword">self</span>.image = image;</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>下一目标: 取消指定<code>URLString</code>的下载操作</p>
</blockquote>
<h2 id="b-取消指定-URLString-的下载操作"><a href="#b-取消指定-URLString-的下载操作" class="headerlink" title="b. 取消指定 URLString 的下载操作"></a>b. 取消指定 URLString 的下载操作</h2><h3 id="目标-1"><a href="#目标-1" class="headerlink" title="目标"></a>目标</h3><ul>
<li>取消指定URLString的下载操作, 以解决图像复用的问题</li>
</ul>
<h3 id="操作步骤-1"><a href="#操作步骤-1" class="headerlink" title="操作步骤"></a>操作步骤</h3><ul>
<li>在<code>DownloadOperationManager.h</code>中增加方法定义</li>
</ul>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-<span class="params">(void)</span>cancelDownloadOperationWithURLString:<span class="params">(NSString *)</span>URLString;</div></pre></td></tr></table></figure>
<ul>
<li>实现该方法</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">-(<span class="keyword">void</span>)cancelDownloadOperationWithURLString:(<span class="built_in">NSString</span> *)URLString&#123;</div><div class="line">    <span class="comment">//从缓存中取到下载操作</span></div><div class="line">    DownloadOperation *operation = [<span class="keyword">self</span>.operationCacheDict objectForKey:URLString];</div><div class="line">    </div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"向之前的下载操作发送取消下载的消息:%@, %@"</span>, URLString, operation);</div><div class="line">    <span class="comment">//发送取消操作的消息</span></div><div class="line">    <span class="keyword">if</span> (operation != <span class="literal">nil</span>) &#123;</div><div class="line">        [operation cancel];</div><div class="line">        <span class="comment">//将操作从缓存中移除</span></div><div class="line">        [<span class="keyword">self</span>.operationCacheDict removeObjectForKey:URLString];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>在<code>UIImageView</code>的分类方法中调用方法, 取消之前已有的下载操作</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//当准备下载的图像的url与此前该cell中准备下载的图像url不等, 且该cell中至少有一个图像正在下载时</span></div><div class="line"><span class="comment">//取消之前的下载操作(取消操作将在后面实现)</span></div><div class="line"><span class="keyword">if</span> (![URLString isEqualToString:<span class="keyword">self</span>.URLString] &amp;&amp; <span class="keyword">self</span>.URLString != <span class="literal">nil</span>) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"取消之前的下载操作"</span>);</div><div class="line">    <span class="comment">//进行取消操作</span></div><div class="line">    [[DownloadOperationManager sharedManager] cancelDownloadOperationWithURLString:<span class="keyword">self</span>.URLString];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>运行测试<br><img src="http://d.pr/i/1jpDm+" alt="测试"><br>可以看到已经比较好的解决了图像重复下载的问题, 当滑动时, 未下载图像的cell会先取消之前的下载操作, 重新下载当前图像</p>
</blockquote>
<h2 id="c-内存警告处理"><a href="#c-内存警告处理" class="headerlink" title="c. 内存警告处理"></a>c. 内存警告处理</h2><h3 id="目标-2"><a href="#目标-2" class="headerlink" title="目标"></a>目标</h3><ul>
<li>学习<code>SDWebImage</code>的内存警告方法, 处理内存警告</li>
</ul>
<h3 id="操作步骤-2"><a href="#操作步骤-2" class="headerlink" title="操作步骤"></a>操作步骤</h3><ul>
<li>在<code>DownloadOperationManager</code>的<code>init</code>方法中注册内存警告通知</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">-(<span class="keyword">instancetype</span>)init</div><div class="line">&#123;</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</div><div class="line">        _downloadQueque = [[<span class="built_in">NSOperationQueue</span> alloc] init];</div><div class="line">        _imageCacheDict = [<span class="built_in">NSMutableDictionary</span> dictionary];</div><div class="line">        _operationCacheDict = [<span class="built_in">NSMutableDictionary</span> dictionary];</div><div class="line">        </div><div class="line">        <span class="comment">//注册内存警告通知</span></div><div class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(memoryWarning) name:<span class="built_in">UIApplicationDidReceiveMemoryWarningNotification</span> object:<span class="literal">nil</span>];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//下载管理器销毁时, 注销通知中心</span></div><div class="line">-(<span class="keyword">void</span>)dealloc&#123;</div><div class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] removeObserver:<span class="keyword">self</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>实现内存警告方法</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">-(<span class="keyword">void</span>)memoryWarning &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"memory warning received!"</span>);</div><div class="line">    </div><div class="line">    [<span class="keyword">self</span>.imageCacheDict removeAllObjects];</div><div class="line">    [<span class="keyword">self</span>.operationCacheDict removeAllObjects];</div><div class="line">    </div><div class="line">    [<span class="keyword">self</span>.downloadQueque cancelAllOperations];</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[模拟SDWebImage异步下载图片操作(四) 仿SDWebImage的操作]]></title>
      <url>http://yoursite.com/2016/08/03/%E6%A8%A1%E6%8B%9FSDWebImage%E5%BC%82%E6%AD%A5%E4%B8%8B%E8%BD%BD%E5%9B%BE%E7%89%87%E6%93%8D%E4%BD%9C(%E5%9B%9B)%20%E4%BB%BFSDWebImage%E7%9A%84%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul>
<li>在上一阶段<code>异步加载网络图像</code>的基础上模拟<code>SDWebImage</code>的实现</li>
<li>深入理解异步加载网络图像的流程</li>
<li>掌握<code>runtime</code>关联对象的使用和应用场景</li>
</ul>
<h2 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h2><p><img src="http://d.pr/i/vcEz+" alt="架构设计"></p>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><h4 id="实现下载管理器单例"><a href="#实现下载管理器单例" class="headerlink" title="实现下载管理器单例"></a>实现下载管理器单例</h4><ul>
<li>新建下载管理器单例</li>
<li>将<code>viewController</code>中有关<code>图像缓存</code>/<code>下载操作</code>逻辑判断的代码直接移植到下载管理器中<h4 id="实现图像下载操作"><a href="#实现图像下载操作" class="headerlink" title="实现图像下载操作"></a>实现图像下载操作</h4></li>
<li>将控制器中的有关<code>图像下载</code>的逻辑移植到下载操作中, 并设置接口, 使得管理器能够直接调用</li>
</ul>
<blockquote>
<p>待图像下载工作完成后, 导入<code>UIImageView</code>分类方法, 利用运行时的关联对象解决图像复用问题</p>
</blockquote>
<h2 id="a-实现下载管理器"><a href="#a-实现下载管理器" class="headerlink" title="a. 实现下载管理器"></a>a. 实现下载管理器</h2><h3 id="目标-1"><a href="#目标-1" class="headerlink" title="目标"></a>目标</h3><ul>
<li>实现所有的图像异步下载管理</li>
</ul>
<h3 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h3><ul>
<li>新建下载管理器继承自<code>NSObject</code></li>
<li>定义接口</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;UIKit/UIKit.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">DownloadOperationManager</span> : <span class="title">NSObject</span></span></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> *  下载管理器单例的全局访问点</div><div class="line"> *</div><div class="line"> *  @return 下载管理器单例</div><div class="line"> */</div><div class="line">+(<span class="keyword">instancetype</span>)sharedManager;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> *  通过URL下载图像的对象方法</div><div class="line"> *</div><div class="line"> *  @param URLString  要下载图像的URL</div><div class="line"> *  @param completion 下载完成时的回调</div><div class="line"> */</div><div class="line">-(<span class="keyword">void</span>)downloadImageWithURLString:(<span class="built_in">NSString</span> *)URLString completion:(<span class="keyword">void</span>(^)(<span class="built_in">UIImage</span> *))completion;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<h4 id="实现单例方法"><a href="#实现单例方法" class="headerlink" title="实现单例方法"></a>实现单例方法</h4><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">+(<span class="keyword">instancetype)sharedManager&#123;</span></div><div class="line">    static DownloadOperationManager *manager<span class="comment">;</span></div><div class="line">    </div><div class="line">    static <span class="keyword">dispatch_once_t </span>onceToken<span class="comment">;</span></div><div class="line">    <span class="keyword">dispatch_once(&amp;onceToken, </span>^&#123;</div><div class="line">        manager = [[DownloadOperationManager alloc] init]<span class="comment">;</span></div><div class="line">    &#125;)<span class="comment">;</span></div><div class="line">    </div><div class="line">    return manager<span class="comment">;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>在类延展中定义相关成员变量</li>
</ul>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="variable">@interface</span> DownloadOperationManager ()</div><div class="line"></div><div class="line"><span class="variable">@property</span> (nonatomic, strong) NSOperationQueue *downloadQueque;</div><div class="line"><span class="variable">@property</span> (nonatomic, strong) NSMutableDictionary *imageCacheDict;</div><div class="line"><span class="variable">@property</span> (nonatomic, strong) NSMutableDictionary *operationCacheDict;</div><div class="line"></div><div class="line"><span class="variable">@end</span></div></pre></td></tr></table></figure>
<ul>
<li>实现<code>init</code>方法实例化相关成员变量</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">instancetype</span>)init</div><div class="line">&#123;</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</div><div class="line">        _downloadQueque = [[<span class="built_in">NSOperationQueue</span> alloc] init];</div><div class="line">        _imageCacheDict = [<span class="built_in">NSMutableDictionary</span> dictionary];</div><div class="line">        _operationCacheDict = [<span class="built_in">NSMutableDictionary</span> dictionary];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="实现下载操作代码"><a href="#实现下载操作代码" class="headerlink" title="实现下载操作代码"></a>实现下载操作代码</h4><ul>
<li>缓存图片的时候, 由于是采用使用URL的<code>lastPathComponent</code>作为缓存图片的文件名进行存储的, 因此当前面的地址不同, 而<code>lastPathComponent</code>相同时, 可能造成缓存混乱, 例如:<blockquote>
<p>www.zhihu.com/123.png<br>www.baidu.com/123.png</p>
</blockquote>
</li>
<li>上面两个文件缓存后会导致覆盖!!!</li>
<li>因此要保证每一个文件在缓存的时候都能得到唯一的文件名</li>
<li>所以将缓存图片的url进行md5操作后, 能够使得缓存数据获得唯一性</li>
<li>导入<code>NSString+hash</code>分类, 该类中的方法可以进行一系列的加密操作, 我们使用其中的md5操作</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">-(<span class="built_in">NSString</span> *)filePathWithURLString:(<span class="built_in">NSString</span> *)URLString &#123;</div><div class="line">    <span class="comment">//获取沙盒缓存路径</span></div><div class="line">    <span class="built_in">NSString</span> *cachesPath = <span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSCachesDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>)[<span class="number">0</span>];</div><div class="line">    <span class="comment">//将URL进行md5操作</span></div><div class="line">    <span class="built_in">NSString</span> *md5_fileName = [URLString cz_md5String];</div><div class="line">    <span class="comment">//合成缓存文件路径</span></div><div class="line">    <span class="built_in">NSString</span> *cacheFilePath = [cachesPath stringByAppendingPathComponent:md5_fileName];</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> cacheFilePath;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>将逻辑判断的代码剪切到<code>下载管理器</code>中</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">-(<span class="keyword">void</span>)downloadImageWithURLString:(<span class="built_in">NSString</span> *)URLString completion:(<span class="keyword">void</span> (^)(<span class="built_in">UIImage</span> *))completion&#123;</div><div class="line">    <span class="built_in">NSAssert</span>(completion != <span class="literal">nil</span>, <span class="string">@"必须传入完成回调"</span>);</div><div class="line">    </div><div class="line">    <span class="built_in">UIImage</span> *cacheImage = <span class="keyword">self</span>.imageCacheDict[URLString];</div><div class="line">    <span class="comment">//判断图像是否已经被缓存</span></div><div class="line">    <span class="comment">//如果缓存 则直接将缓存中的图像显示在iconView上</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.imageCacheDict[URLString] != <span class="literal">nil</span>) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"图像已经从字典缓存中取出"</span>);</div><div class="line">        completion(cacheImage);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//获取沙盒路径</span></div><div class="line">    <span class="built_in">NSString</span> *cachePath = [<span class="keyword">self</span> filePathWithURLString:URLString];</div><div class="line">    <span class="comment">//判断沙盒中是否已经缓存了图片</span></div><div class="line">    cacheImage = [<span class="built_in">UIImage</span> imageWithContentsOfFile:cachePath];</div><div class="line">    <span class="keyword">if</span> (cacheImage != <span class="literal">nil</span>) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"图像已经从沙盒中取出"</span>);</div><div class="line">        <span class="comment">//如果缓存了图片, 则向图像缓存字典中存储一份, 并将图像直接显示到cell的iconView上</span></div><div class="line">        [<span class="keyword">self</span>.imageCacheDict setObject:cacheImage forKey:URLString];</div><div class="line">        completion(cacheImage);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//判断操作是否已经在队列中, 如果操作已经存在, 那么直接返回</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.operationCacheDict[URLString] != <span class="literal">nil</span>) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"downloading......"</span>);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>运行测试<br>此时程序本质上没有进行任何改动, 程序运行和之前应该没有任何区别<br>下一目标: 自定义下载操作</p>
</blockquote>
<h2 id="b-实现下载操作"><a href="#b-实现下载操作" class="headerlink" title="b. 实现下载操作"></a>b. 实现下载操作</h2><h3 id="目标-2"><a href="#目标-2" class="headerlink" title="目标"></a>目标</h3><ul>
<li>实现下载操作, 处理单独的文件下载</li>
<li>体会<code>isCancelled</code>属性的使用</li>
<li>掌握在自定义<code>operation</code>时, 需要:<ul>
<li>重写<code>main</code>方法</li>
</ul>
</li>
</ul>
<h3 id="操作步骤-1"><a href="#操作步骤-1" class="headerlink" title="操作步骤"></a>操作步骤</h3><ul>
<li>新建下载操作<code>DownloadOperation</code>继承自<code>NSOperation</code></li>
<li>定义相关接口如下</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;UIKit/UIKit.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">DownloadOperation</span> : <span class="title">NSOperation</span></span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIImage</span> *downloadImage;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> *  下载操作</div><div class="line"> *</div><div class="line"> *  @param URLString 要下载文件的URL路径</div><div class="line"> *  @param cachePath 缓存文件的地址</div><div class="line"> *</div><div class="line"> *  @return 创建好的下载操作</div><div class="line"> */</div><div class="line">+(<span class="keyword">instancetype</span>)downloadOperationWithURLString:(<span class="built_in">NSString</span> *)URLString cachePath:(<span class="built_in">NSString</span> *)cachePath;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<h4 id="实现类方法"><a href="#实现类方法" class="headerlink" title="实现类方法"></a>实现类方法</h4><ul>
<li>在类扩展中定义属性</li>
</ul>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="variable">@interface</span> DownloadOperation ()</div><div class="line"></div><div class="line"><span class="variable">@property</span> (nonatomic, copy) NSString *URLString;</div><div class="line"><span class="variable">@property</span> (nonatomic, copy) NSString *cachePath;</div><div class="line"></div><div class="line"><span class="variable">@end</span></div></pre></td></tr></table></figure>
<ul>
<li>实现类方法, 记录属性值</li>
</ul>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">+(instance<span class="keyword">type</span>)downloadOperationWithURLString:(<span class="type">NSString</span> *)<span class="type">URLString</span> cachePath:(<span class="type">NSString</span> *)cachePath&#123;</div><div class="line">    <span class="type">DownloadOperation</span> *operation = [[<span class="type">DownloadOperation</span> alloc] init];</div><div class="line">    </div><div class="line">    operation.<span class="type">URLString</span> = <span class="type">URLString</span>;</div><div class="line">    operation.cachePath = cachePath;</div><div class="line">    </div><div class="line">    return operation;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="实现main方法"><a href="#实现main方法" class="headerlink" title="实现main方法"></a>实现<code>main</code>方法</h4><blockquote>
<ul>
<li><code>main</code>方法是自定义操作的入口方法</li>
<li>添加操作是否被取消的判断</li>
</ul>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">-(<span class="keyword">void</span>)main&#123;</div><div class="line">    <span class="comment">//生成下载URL</span></div><div class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="keyword">self</span>.URLString];</div><div class="line">    </div><div class="line">    <span class="comment">//判断下载链接是否生成成功</span></div><div class="line">    <span class="keyword">if</span> (url == <span class="literal">nil</span>) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"下载地址错误"</span>);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//判断操作是否已被取消</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.isCancelled) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"下载操作被取消了!"</span>);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//下载</span></div><div class="line">    <span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfURL:url];</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (data != <span class="literal">nil</span>) &#123;</div><div class="line">        <span class="comment">//将数据写入沙盒中</span></div><div class="line">        [data writeToFile:<span class="keyword">self</span>.cachePath atomically:<span class="literal">YES</span>];</div><div class="line">        <span class="comment">//将二进制数据转换成图像</span></div><div class="line">        <span class="keyword">self</span>.downloadImage = [<span class="built_in">UIImage</span> imageWithData:data];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="c-在下载管理器中增加下载操作"><a href="#c-在下载管理器中增加下载操作" class="headerlink" title="c. 在下载管理器中增加下载操作"></a>c. 在下载管理器中增加下载操作</h2><h3 id="目标-3"><a href="#目标-3" class="headerlink" title="目标"></a>目标</h3><ul>
<li>在下载管理器中增加下载操作</li>
<li>测试下载的沙盒缓存和内存缓存</li>
</ul>
<h3 id="操作步骤-2"><a href="#操作步骤-2" class="headerlink" title="操作步骤"></a>操作步骤</h3><ul>
<li>在<code>DownloadOperationManager</code>中导入<code>DownloadOperation</code>的头文件</li>
<li>在<code>DownloadOperationManager</code>中继续实现<code>downloadImageWithURLString: completion:</code>方法</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">-(<span class="keyword">void</span>)downloadImageWithURLString:(<span class="built_in">NSString</span> *)URLString completion:(<span class="keyword">void</span> (^)(<span class="built_in">UIImage</span> *))completion&#123;</div><div class="line">    <span class="built_in">NSAssert</span>(completion != <span class="literal">nil</span>, <span class="string">@"必须传入完成回调"</span>);</div><div class="line">    </div><div class="line">    <span class="built_in">UIImage</span> *cacheImage = [<span class="keyword">self</span>.imageCacheDict objectForKey:URLString];</div><div class="line">    <span class="comment">//判断图像是否已经被缓存</span></div><div class="line">    <span class="comment">//如果缓存 则直接将缓存中的图像显示在iconView上</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.imageCacheDict[URLString] != <span class="literal">nil</span>) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"图像已经从字典缓存中取出"</span>);</div><div class="line">        completion(cacheImage);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//获取沙盒路径</span></div><div class="line">    <span class="built_in">NSString</span> *cachePath = [<span class="keyword">self</span> filePathWithURLString:URLString];</div><div class="line">    <span class="comment">//判断沙盒中是否已经缓存了图片</span></div><div class="line">    cacheImage = [<span class="built_in">UIImage</span> imageWithContentsOfFile:cachePath];</div><div class="line">    <span class="keyword">if</span> (cacheImage != <span class="literal">nil</span>) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"图像已经从沙盒中取出"</span>);</div><div class="line">        <span class="comment">//如果缓存了图片, 则向图像缓存字典中存储一份, 并将图像直接显示到cell的iconView上</span></div><div class="line">        [<span class="keyword">self</span>.imageCacheDict setObject:cacheImage forKey:URLString];</div><div class="line">        completion(cacheImage);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//判断操作是否已经在队列中, 如果操作已经存在, 那么直接返回</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.operationCacheDict[URLString] != <span class="literal">nil</span>) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"downloading......"</span>);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//实例化下载操作</span></div><div class="line">    DownloadOperation *operation = [DownloadOperation downloadOperationWithURLString:URLString cachePath:cachePath];</div><div class="line">    <span class="comment">//监听下载完成的操作</span></div><div class="line">    [operation setCompletionBlock:^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"下载已完成 %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</div><div class="line">    &#125;];</div><div class="line">    <span class="comment">//将操作加入下载队列, 并添加到操作缓存中</span></div><div class="line">    [<span class="keyword">self</span>.downloadQueque addOperation:operation];</div><div class="line">    [<span class="keyword">self</span>.operationCacheDict setObject:operation forKey:URLString];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="修改ViewController代码"><a href="#修改ViewController代码" class="headerlink" title="修改ViewController代码"></a>修改<code>ViewController</code>代码</h4><h5 id="修改前的准备"><a href="#修改前的准备" class="headerlink" title="修改前的准备"></a>修改前的准备</h5><ul>
<li>在视图控制器中, 删除和下载相关的属性</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSOperationQueue</span> *downloadQueque;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableDictionary</span> *imageCacheDict;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableDictionary</span> *operationCacheDict;</div></pre></td></tr></table></figure>
<ul>
<li>删除懒加载的相关代码</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">-(<span class="built_in">NSOperationQueue</span> *)downloadQueque&#123;</div><div class="line">    <span class="keyword">if</span> (_downloadQueque == <span class="literal">nil</span>) &#123;</div><div class="line">        _downloadQueque = [[<span class="built_in">NSOperationQueue</span> alloc] init];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> _downloadQueque;</div><div class="line">&#125;</div><div class="line"></div><div class="line">-(<span class="built_in">NSMutableDictionary</span> *)imageCacheDict&#123;</div><div class="line">    <span class="keyword">if</span> (_imageCacheDict == <span class="literal">nil</span>) &#123;</div><div class="line">        _imageCacheDict = [<span class="built_in">NSMutableDictionary</span> dictionary];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> _imageCacheDict;</div><div class="line">&#125;</div><div class="line"></div><div class="line">-(<span class="built_in">NSMutableDictionary</span> *)operationCacheDict&#123;</div><div class="line">    <span class="keyword">if</span> (_operationCacheDict == <span class="literal">nil</span>) &#123;</div><div class="line">        _operationCacheDict = [<span class="built_in">NSMutableDictionary</span> dictionary];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> _operationCacheDict;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>注释掉<code>didReceiveMemoryWarning</code>方法</li>
</ul>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">-</span>(void)<span class="selector-tag">didReceiveMemoryWarning</span>&#123;</div><div class="line">    <span class="selector-attr">[super didReceiveMemoryWarning]</span>;</div><div class="line">    <span class="comment">//移除缓存中的所有对象</span></div><div class="line">    <span class="selector-attr">[self.imageCacheDict removeAllObjects]</span>;</div><div class="line">    <span class="selector-attr">[self.operationCacheDict removeAllObjects]</span>;</div><div class="line">    <span class="comment">//取消队列中的所有操作</span></div><div class="line">    <span class="selector-attr">[self.downloadQueque cancelAllOperations]</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="使用下载操作管理器下载图像"><a href="#使用下载操作管理器下载图像" class="headerlink" title="使用下载操作管理器下载图像"></a>使用下载操作管理器下载图像</h5><ul>
<li>导入头文件</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#import</span> <span class="string">"DownloadOperationManager.h"</span></div></pre></td></tr></table></figure>
<ul>
<li>修改数据源方法</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">-(UITableViewCell *)<span class="string">tableView:</span>(UITableView *)tableView <span class="string">cellForRowAtIndexPath:</span>(NSIndexPath *)indexPath&#123;</div><div class="line">    </div><div class="line">    AppCell *cell = [tableView <span class="string">dequeueReusableCellWithIdentifier:</span>cellID <span class="string">forIndexPath:</span>indexPath];</div><div class="line">    </div><div class="line">    AppInfo *info = self.app_infos[indexPath.row];</div><div class="line">    </div><div class="line">    cell.appName.text = info.name;</div><div class="line">    cell.downCount.text = info.download;</div><div class="line">    <span class="comment">//在这里设置占位图像 用来解决图像闪动的问题</span></div><div class="line">    cell.iconView.image = [UIImage <span class="string">imageNamed:</span>@<span class="string">"user_default"</span>];</div><div class="line">    </div><div class="line">    DownloadOperationManager *manager = [DownloadOperationManager sharedManager];</div><div class="line">    </div><div class="line">    [manager <span class="string">downloadImageWithURLString:</span>info.icon <span class="string">completion:</span>^(UIImage *image) &#123;</div><div class="line">        cell.iconView.image = image;</div><div class="line">    &#125;];</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> cell;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="下载完成后完成回调"><a href="#下载完成后完成回调" class="headerlink" title="下载完成后完成回调"></a>下载完成后完成回调</h5><ul>
<li>在下载管理中实现<code>setCompletionBlock</code>的代码</li>
</ul>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[<span class="name">operation</span> setCompletionBlock:^&#123;</div><div class="line">    NSLog(<span class="name">@</span><span class="string">"下载已完成 %@"</span>, [<span class="name">NSThread</span> currentThread])<span class="comment">;</span></div><div class="line">    </div><div class="line">    //主线程回调</div><div class="line">    [[<span class="name">NSOperationQueue</span> mainQueue] addOperationWithBlock:^&#123;</div><div class="line">        completion(<span class="name">operation.downloadImage</span>)<span class="comment">;</span></div><div class="line">    &#125;]<span class="comment">;</span></div><div class="line">&#125;]<span class="comment">;</span></div></pre></td></tr></table></figure>
<blockquote>
<p>系统会提示循环引用了! 因为在<code>operation</code>的<code>completionBlock</code>中使用了<code>operation</code>自身</p>
</blockquote>
<ul>
<li>使用<code>__weak</code>解决循环引用的问题, 并完善代码</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//实例化下载操作</span></div><div class="line">DownloadOperation *operation = [DownloadOperation downloadOperationWithURLString:URLString cachePath:cachePath];</div><div class="line"></div><div class="line">__<span class="keyword">weak</span> DownloadOperation *weakSelf = operation;</div><div class="line"></div><div class="line"><span class="comment">//监听下载完成的操作</span></div><div class="line">[operation setCompletionBlock:^&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"下载已完成 %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</div><div class="line">    <span class="comment">//获取下载好的图片</span></div><div class="line">    <span class="built_in">UIImage</span> *cacheImage = weakSelf.downloadImage;</div><div class="line">    </div><div class="line">    <span class="comment">//下载完成后删除操作</span></div><div class="line">    [<span class="keyword">self</span>.operationCacheDict removeObjectForKey:URLString];</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (cacheImage != <span class="literal">nil</span>) &#123;</div><div class="line">        <span class="comment">//存入字典缓存中</span></div><div class="line">        [<span class="keyword">self</span>.imageCacheDict setObject:cacheImage forKey:URLString];</div><div class="line">        </div><div class="line">        <span class="comment">//主线程回调</span></div><div class="line">        [[<span class="built_in">NSOperationQueue</span> mainQueue] addOperationWithBlock:^&#123;</div><div class="line">            completion(weakSelf.downloadImage);</div><div class="line">        &#125;];</div><div class="line">    &#125;</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<blockquote>
<p>运行测试<br><img src="http://d.pr/i/1eOaG+" alt="测试"></p>
</blockquote>
<ul>
<li>在<code>DownloadOperation</code>中添加模拟延时的代码, 测试操作的缓存情况</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">-(<span class="keyword">void</span>)main&#123;</div><div class="line">    <span class="comment">//生成下载URL</span></div><div class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="keyword">self</span>.URLString];</div><div class="line">    </div><div class="line">    <span class="comment">//模拟网络延迟</span></div><div class="line">    [<span class="built_in">NSThread</span> sleepForTimeInterval:arc4random_uniform(<span class="number">5</span>)];</div><div class="line">    </div><div class="line">    <span class="comment">//判断下载链接是否生成成功</span></div><div class="line">    <span class="keyword">if</span> (url == <span class="literal">nil</span>) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"下载地址错误"</span>);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//判断操作是否已被取消</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.isCancelled) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"下载操作被取消了!"</span>);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//下载</span></div><div class="line">    <span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfURL:url];</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (data != <span class="literal">nil</span>) &#123;</div><div class="line">        <span class="comment">//将数据写入沙盒中</span></div><div class="line">        [data writeToFile:<span class="keyword">self</span>.cachePath atomically:<span class="literal">YES</span>];</div><div class="line">        <span class="comment">//将二进制数据转换成图像</span></div><div class="line">        <span class="keyword">self</span>.downloadImage = [<span class="built_in">UIImage</span> imageWithData:data];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>运行测试<br><img src="http://d.pr/i/Dlua+" alt="测试"><br>下一目标: 建立<code>UIImageView</code>的分类方法</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[模拟SDWebImage异步下载图片操作(三)]]></title>
      <url>http://yoursite.com/2016/08/02/%E6%A8%A1%E6%8B%9FSDWebImage%E5%BC%82%E6%AD%A5%E4%B8%8B%E8%BD%BD%E5%9B%BE%E7%89%87%E6%93%8D%E4%BD%9C(%E4%B8%89)/</url>
      <content type="html"><![CDATA[<h2 id="异步图像-操作缓存"><a href="#异步图像-操作缓存" class="headerlink" title="异步图像-操作缓存"></a>异步图像-操作缓存</h2><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><ul>
<li>建立<code>操作缓存字典</code>, 缓存下载操作, 避免操作被重复创建</li>
</ul>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><ul>
<li>在<code>viewController</code>中定义<code>操作缓存字典</code>属性</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableDictionary</span> *operationCacheDict;</div></pre></td></tr></table></figure>
<ul>
<li>懒加载操作缓存字典</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">-(<span class="built_in">NSMutableDictionary</span> *)operationCacheDict&#123;</div><div class="line">    <span class="keyword">if</span> (_operationCacheDict == <span class="literal">nil</span>) &#123;</div><div class="line">        _operationCacheDict = [<span class="built_in">NSMutableDictionary</span> dictionary];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> _operationCacheDict;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>a.修改数据源方法, 在下载操作前, 判断下载操作是否已经存在</li>
<li>b.在数据源方法的末尾, 将操作添加到<code>操作缓存字典</code>中</li>
<li>c.在下载操作完成后, 应将操作移除</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">-(<span class="built_in">UITableViewCell</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath&#123;</div><div class="line">    </div><div class="line">    AppCell *cell = [tableView dequeueReusableCellWithIdentifier:cellID forIndexPath:indexPath];</div><div class="line">    </div><div class="line">    AppInfo *info = <span class="keyword">self</span>.app_infos[indexPath.row];</div><div class="line">    </div><div class="line">    cell.appName.text = info.name;</div><div class="line">    cell.downCount.text = info.download;</div><div class="line">    <span class="comment">//在这里设置占位图像 用来解决图像闪动的问题</span></div><div class="line">    cell.iconView.image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"user_default"</span>];</div><div class="line">    </div><div class="line">    <span class="comment">//判断图像是否已经被缓存</span></div><div class="line">    <span class="comment">//如果缓存 则直接将缓存中的图像显示在iconView上</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.imageCacheDict[info.icon] != <span class="literal">nil</span>) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@ 的图像已经从字典缓存中取出"</span>, info.name);</div><div class="line">        cell.iconView.image = <span class="keyword">self</span>.imageCacheDict[info.icon];</div><div class="line">        <span class="keyword">return</span> cell;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//a. 判断操作是否已经在队列中, 如果操作已经存在, 那么直接返回</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.operationCacheDict[info.icon] != <span class="literal">nil</span>) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@ is downloading"</span>, info.name);</div><div class="line">        <span class="keyword">return</span> cell;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="keyword">self</span>.app_infos[indexPath.row].icon];</div><div class="line">    </div><div class="line">    <span class="built_in">NSBlockOperation</span> *op = [<span class="built_in">NSBlockOperation</span>  blockOperationWithBlock:^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"正在下载 %@ 的图片"</span>, <span class="keyword">self</span>.app_infos[indexPath.row].name);</div><div class="line">        <span class="comment">//在这里加入模拟网络延迟的代码</span></div><div class="line">        <span class="comment">//模拟下载环境有随机延迟 可以看到有操作被重复添加了</span></div><div class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:arc4random_uniform(<span class="number">10</span>)];</div><div class="line">        </div><div class="line">        <span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfURL:url];</div><div class="line">        <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageWithData:data];</div><div class="line">        </div><div class="line">        <span class="comment">//在主线程中更新UI</span></div><div class="line">        [[<span class="built_in">NSOperationQueue</span> mainQueue] addOperationWithBlock:^&#123;</div><div class="line">            <span class="comment">//查看已经存在的操作数量</span></div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"操作的数量: %ld"</span>, <span class="keyword">self</span>.downloadQueque.operationCount);</div><div class="line">            </div><div class="line">            <span class="comment">//添加到图像字典缓存中</span></div><div class="line">            <span class="comment">//注意!! 字典value不能为nil</span></div><div class="line">            <span class="keyword">if</span> (image != <span class="literal">nil</span>) &#123;</div><div class="line">                [<span class="keyword">self</span>.imageCacheDict setValue:image forKey:info.icon];</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="comment">//c.下载完成, 应将当前下载操作从缓存中移除</span></div><div class="line">            [<span class="keyword">self</span>.operationCacheDict removeObjectForKey:info.icon];</div><div class="line">            </div><div class="line">            cell.iconView.image = image;</div><div class="line">        &#125;];</div><div class="line">    &#125;];</div><div class="line">    </div><div class="line">    <span class="comment">//将操作加入下载队列</span></div><div class="line">    [<span class="keyword">self</span>.downloadQueque addOperation:op];</div><div class="line">    <span class="comment">//b. 将操作加入操作的字典缓存</span></div><div class="line">    [<span class="keyword">self</span>.operationCacheDict setObject:op forKey:info.icon];</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> cell;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>在内存警告中处理缓存操作</li>
</ul>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#pragma</span> <span class="selector-tag">mark</span> <span class="selector-tag">-</span> <span class="selector-tag">memory</span> <span class="selector-tag">Warning</span></div><div class="line"></div><div class="line"><span class="selector-tag">-</span>(void)<span class="selector-tag">didReceiveMemoryWarning</span>&#123;</div><div class="line">    <span class="selector-attr">[super didReceiveMemoryWarning]</span>;</div><div class="line">    <span class="comment">//移除缓存中的所有对象</span></div><div class="line">    <span class="selector-attr">[self.imageCacheDict removeAllObjects]</span>;</div><div class="line">    <span class="selector-attr">[self.operationCacheDict removeAllObjects]</span>;</div><div class="line">    <span class="comment">//取消队列中的所有操作</span></div><div class="line">    <span class="selector-attr">[self.downloadQueque cancelAllOperations]</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>运行测试<br><img src="http://d.pr/i/1gMYl+" alt="测试"></p>
</blockquote>
<h2 id="异步图像-沙盒缓存"><a href="#异步图像-沙盒缓存" class="headerlink" title="异步图像-沙盒缓存"></a>异步图像-沙盒缓存</h2><h3 id="沙盒目录介绍"><a href="#沙盒目录介绍" class="headerlink" title="沙盒目录介绍"></a>沙盒目录介绍</h3><ul>
<li>Documents<ul>
<li>保存由应用程序产生的文件或者数据，例如：涂鸦程序生成的图片，游戏关卡记录</li>
<li>iCloud 会自动备份<code>Document</code>中的所有文件</li>
<li>如果保存了从网络下载的文件，在上架审批的时候，会被拒！</li>
</ul>
</li>
<li>tmp<ul>
<li>临时文件夹，保存临时文件</li>
<li>保存在<code>tmp</code>文件夹中的文件，系统会自动回收，譬如磁盘空间紧张或者重新启动手机</li>
<li>程序员不需要关心<code>tmp</code>文件夹中的释放</li>
</ul>
</li>
<li>Caches<ul>
<li>缓存，保存从网络下载的文件，后续仍然需要继续使用，例如：网络下载的缓存数据，图片</li>
<li><strong>Caches目录下面的文件,当手机存储空间不足的时候,会自动删除</strong></li>
<li><strong>要求程序必需提供一个完善的清除缓存目录的”解决方案”！</strong></li>
</ul>
</li>
<li>preferences<ul>
<li>系统偏好，用户偏好</li>
<li>操作是通过<code>[NSUserDefaults standardDefaults]</code>来直接操作</li>
</ul>
</li>
</ul>
<h3 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h3><h4 id="引入NSString-Path分类"><a href="#引入NSString-Path分类" class="headerlink" title="引入NSString+Path分类"></a>引入<code>NSString+Path</code>分类</h4><ul>
<li>该分类可以简化获取沙盒目录的操作</li>
<li>对url地址使用相关的<code>appending</code>方法, 可以直接生成对应文件名的沙盒地址</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/// 获取Documents目录</span></div><div class="line">- (<span class="built_in">NSString</span> *)appendDocumentsPath</div><div class="line">&#123;</div><div class="line">    <span class="comment">// 获取Documents文件目录</span></div><div class="line">    <span class="built_in">NSString</span> *documentsPath = [<span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSDocumentDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>) lastObject];</div><div class="line">    <span class="comment">// 获取图片的名字</span></div><div class="line">    <span class="built_in">NSString</span> *fileName = [<span class="keyword">self</span> lastPathComponent];</div><div class="line">    <span class="comment">// Documents文件目录拼接图片的名字 == 图片保存到沙盒的路径</span></div><div class="line">    <span class="built_in">NSString</span> *filePath = [documentsPath stringByAppendingPathComponent:fileName];</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> filePath;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/// 获取Cache目录</span></div><div class="line">- (<span class="built_in">NSString</span> *)appendCachePath</div><div class="line">&#123;</div><div class="line">    <span class="comment">// 获取Cache文件目录</span></div><div class="line">    <span class="built_in">NSString</span> *cachePath = [<span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSCachesDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>) lastObject];</div><div class="line">    <span class="comment">// 获取图片的名字</span></div><div class="line">    <span class="built_in">NSString</span> *fileName = [<span class="keyword">self</span> lastPathComponent];</div><div class="line">    <span class="comment">// Cache文件目录拼接图片的名字 == 图片保存到沙盒的路径</span></div><div class="line">    <span class="built_in">NSString</span> *filePath = [cachePath stringByAppendingPathComponent:fileName];</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> filePath;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/// 获取Tmp目录</span></div><div class="line">- (<span class="built_in">NSString</span> *)appendTmpPath</div><div class="line">&#123;</div><div class="line">    <span class="comment">// 获取Documents文件目录</span></div><div class="line">    <span class="built_in">NSString</span> *tmpPath = <span class="built_in">NSTemporaryDirectory</span>();</div><div class="line">    <span class="comment">// 获取图片的名字</span></div><div class="line">    <span class="built_in">NSString</span> *fileName = [<span class="keyword">self</span> lastPathComponent];</div><div class="line">    <span class="comment">// Documents文件目录拼接图片的名字 == 图片保存到沙盒的路径</span></div><div class="line">    <span class="built_in">NSString</span> *filePath = [tmpPath stringByAppendingPathComponent:fileName];</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> filePath;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="沙盒缓存"><a href="#沙盒缓存" class="headerlink" title="沙盒缓存"></a>沙盒缓存</h4><ul>
<li>导入<code>NSString+Path</code>分类头文件</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#import</span> <span class="string">"NSString+path.h"</span></div></pre></td></tr></table></figure>
<ul>
<li>a. 将图像缓存至沙盒中</li>
<li>b. 判断沙盒中是否有图像的缓存, 如果有, 则将沙盒中的图像直接显示在cell的<code>iconView</code>上, 并<code>return cell</code></li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line">-(<span class="built_in">UITableViewCell</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath&#123;</div><div class="line">    </div><div class="line">    AppCell *cell = [tableView dequeueReusableCellWithIdentifier:cellID forIndexPath:indexPath];</div><div class="line">    </div><div class="line">    AppInfo *info = <span class="keyword">self</span>.app_infos[indexPath.row];</div><div class="line">    </div><div class="line">    cell.appName.text = info.name;</div><div class="line">    cell.downCount.text = info.download;</div><div class="line">    <span class="comment">//在这里设置占位图像 用来解决图像闪动的问题</span></div><div class="line">    cell.iconView.image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"user_default"</span>];</div><div class="line">    </div><div class="line">    <span class="comment">//判断图像是否已经被缓存</span></div><div class="line">    <span class="comment">//如果缓存 则直接将缓存中的图像显示在iconView上</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.imageCacheDict[info.icon] != <span class="literal">nil</span>) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@ 的图像已经从字典缓存中取出"</span>, info.name);</div><div class="line">        cell.iconView.image = <span class="keyword">self</span>.imageCacheDict[info.icon];</div><div class="line">        <span class="keyword">return</span> cell;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//获取沙盒路径</span></div><div class="line">    <span class="built_in">NSString</span> *cachePath = [info.icon appendCachePath];</div><div class="line">    </div><div class="line">    <span class="comment">//b. 判断沙盒中是否已经缓存了图片</span></div><div class="line">    <span class="built_in">UIImage</span> *cacheImage = [<span class="built_in">UIImage</span> imageWithContentsOfFile:cachePath];</div><div class="line">    <span class="keyword">if</span> (cacheImage != <span class="literal">nil</span>) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@ 的图像已经从沙盒中取出"</span>, info.name);</div><div class="line">        <span class="comment">//如果缓存了图片, 则向图像缓存字典中存储一份, 并将图像直接显示到cell的iconView上</span></div><div class="line">        [<span class="keyword">self</span>.imageCacheDict setObject:cacheImage forKey:info.icon];</div><div class="line">        cell.iconView.image = cacheImage;</div><div class="line">        <span class="keyword">return</span> cell;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//判断操作是否已经在队列中, 如果操作已经存在, 那么直接返回</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.operationCacheDict[info.icon] != <span class="literal">nil</span>) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@ is downloading"</span>, info.name);</div><div class="line">        <span class="keyword">return</span> cell;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="keyword">self</span>.app_infos[indexPath.row].icon];</div><div class="line">    </div><div class="line">    <span class="built_in">NSBlockOperation</span> *op = [<span class="built_in">NSBlockOperation</span>  blockOperationWithBlock:^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"正在下载 %@ 的图片"</span>, <span class="keyword">self</span>.app_infos[indexPath.row].name);</div><div class="line">        <span class="comment">//在这里加入模拟网络延迟的代码</span></div><div class="line">        <span class="comment">//模拟下载环境有随机延迟 可以看到有操作被重复添加了</span></div><div class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:arc4random_uniform(<span class="number">5</span>)];</div><div class="line">        </div><div class="line">        <span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfURL:url];</div><div class="line">        <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageWithData:data];</div><div class="line">        </div><div class="line">        <span class="comment">//a. 将下载好的图片保存到沙盒中</span></div><div class="line">        [data writeToFile:cachePath atomically:<span class="literal">YES</span>];</div><div class="line">        </div><div class="line">        <span class="comment">//在主线程中更新UI</span></div><div class="line">        [[<span class="built_in">NSOperationQueue</span> mainQueue] addOperationWithBlock:^&#123;</div><div class="line">            <span class="comment">//查看已经存在的操作数量</span></div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"操作的数量: %ld"</span>, <span class="keyword">self</span>.downloadQueque.operationCount);</div><div class="line">            </div><div class="line">            <span class="comment">//添加到图像字典缓存中</span></div><div class="line">            <span class="comment">//注意!! 字典value不能为nil</span></div><div class="line">            <span class="keyword">if</span> (image != <span class="literal">nil</span>) &#123;</div><div class="line">                [<span class="keyword">self</span>.imageCacheDict setValue:image forKey:info.icon];</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="comment">//下载完成, 应将当前下载操作从缓存中移除</span></div><div class="line">            [<span class="keyword">self</span>.operationCacheDict removeObjectForKey:info.icon];</div><div class="line">            </div><div class="line">            cell.iconView.image = image;</div><div class="line">        &#125;];</div><div class="line">    &#125;];</div><div class="line">    </div><div class="line">    <span class="comment">//将操作加入下载队列</span></div><div class="line">    [<span class="keyword">self</span>.downloadQueque addOperation:op];</div><div class="line">    <span class="comment">//将操作加入操作的字典缓存</span></div><div class="line">    [<span class="keyword">self</span>.operationCacheDict setObject:op forKey:info.icon];</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> cell;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>运行测试<br>可以看到, 程序刚开始运行的时候, 当沙盒中缓存了图片时, 将直接从沙盒中加载图片, 而第二次加载图片时, 则会直接从缓存字典中取出了<br><img src="http://d.pr/i/Lg8E+" alt="测试"><br><img src="http://d.pr/i/1aDEG+" alt="沙盒缓存"></p>
</blockquote>
<p><strong>至此, 模拟SDWebImage就完成了, 下一步, 我将继续尝试简单模仿一下SDWebImage的内部实现</strong></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[模拟SDWebImage异步下载图片操作(二)]]></title>
      <url>http://yoursite.com/2016/08/01/%E6%A8%A1%E6%8B%9FSDWebImage%E5%BC%82%E6%AD%A5%E4%B8%8B%E8%BD%BD%E5%9B%BE%E7%89%87%E6%93%8D%E4%BD%9C(%E4%BA%8C)/</url>
      <content type="html"><![CDATA[<h2 id="异步图像-自行加载"><a href="#异步图像-自行加载" class="headerlink" title="异步图像-自行加载"></a>异步图像-自行加载</h2><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><ul>
<li>自行加载异步图像</li>
<li>设置</li>
</ul>
<h3 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h3><h4 id="异步下载的简单实现"><a href="#异步下载的简单实现" class="headerlink" title="异步下载的简单实现"></a>异步下载的简单实现</h4><ul>
<li>定义操作队列</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSOperationQueue</span> *queque;</div></pre></td></tr></table></figure>
<ul>
<li>懒加载操作队列</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">-(<span class="built_in">NSOperationQueue</span> *)queque&#123;</div><div class="line">    <span class="keyword">if</span> (_queque == <span class="literal">nil</span>) &#123;</div><div class="line">        _queque = [[<span class="built_in">NSOperationQueue</span> alloc] init];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> _queque;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>修改数据源方法</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">-(<span class="built_in">UITableViewCell</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath&#123;</div><div class="line">    </div><div class="line">    AppCell *cell = [tableView dequeueReusableCellWithIdentifier:cellID forIndexPath:indexPath];</div><div class="line">    </div><div class="line">    AppInfo *info = <span class="keyword">self</span>.app_infos[indexPath.row];</div><div class="line">    </div><div class="line">    cell.appName.text = info.name;</div><div class="line">    cell.downCount.text = info.download;</div><div class="line">    </div><div class="line">    <span class="comment">//将使用SDWebImage加载图片的代码注释掉</span></div><div class="line"><span class="comment">//    [cell.iconView sd_setImageWithURL:[NSURL URLWithString:info.icon]];</span></div><div class="line">    </div><div class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="keyword">self</span>.app_infos[indexPath.row].icon];</div><div class="line">    </div><div class="line">    <span class="built_in">NSBlockOperation</span> *op = [<span class="built_in">NSBlockOperation</span>  blockOperationWithBlock:^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"正在下载 %@ 的图片"</span>, <span class="keyword">self</span>.app_infos[indexPath.row].name);</div><div class="line">        </div><div class="line">        <span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfURL:url];</div><div class="line">        <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageWithData:data];</div><div class="line">        </div><div class="line">        [[<span class="built_in">NSOperationQueue</span> mainQueue] addOperationWithBlock:^&#123;</div><div class="line">            cell.iconView.image = image;</div><div class="line">        &#125;];</div><div class="line">    &#125;];</div><div class="line">    </div><div class="line">    [<span class="keyword">self</span>.downloadQueque addOperation:op];</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> cell;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>运行测试<br><img src="http://d.pr/i/lh1F+" alt="测试"></p>
</blockquote>
<h4 id="模拟延时"><a href="#模拟延时" class="headerlink" title="模拟延时"></a>模拟延时</h4><ul>
<li>模拟网络延时</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"正在下载 %@ 的图片"</span>, <span class="keyword">self</span>.app_infos[indexPath.row].name);</div><div class="line"><span class="comment">//在这里加入模拟网络延迟的代码</span></div><div class="line">[<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">0.5</span>];</div></pre></td></tr></table></figure>
<blockquote>
<p>运行测试, 快速滚动表格</p>
<ul>
<li>会发现表格行的cell因为复用, 出现图片闪动的问题<br><img src="http://d.pr/i/13Kmz+" alt="图片闪动"></li>
<li>表格的复用问题：没有在数据源方法中更新显示</li>
<li>解决办法：使用占位图像</li>
</ul>
</blockquote>
<ul>
<li>在数据源方法中设置占位图像</li>
</ul>
<figure class="highlight sqf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">cell.appName.<span class="built_in">text</span> = info.<span class="built_in">name</span>;</div><div class="line">cell.downCount.<span class="built_in">text</span> = info.download;</div><div class="line"><span class="comment">//在这里设置占位图像(图像素材请自行寻找) 用来解决图像闪动的问题</span></div><div class="line">cell.iconView.<span class="built_in">image</span> = [UIImage imageNamed:@<span class="string">"user_default"</span>];</div></pre></td></tr></table></figure>
<blockquote>
<p>运行测试<br><img src="http://d.pr/i/hNrP+" alt="设置占位图像"></p>
<ul>
<li>每次图像都从网络下载，浪费流量</li>
<li>每次都显示占位图像，造成不好的用户体验</li>
<li>合理的解决方案：图像没有下载显示占位图像，如果下载完成，直接显示图像</li>
<li>解决办法一：在模型中缓存图像<ul>
<li>优点：简单</li>
<li>缺点：内存不足时不好释放资源</li>
</ul>
</li>
<li>解决办法二：新建图像缓存字典<ul>
<li>优点：能够单独管理图像的内存缓存</li>
<li>缺点：代码要稍微繁琐一些</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="异步图像-使用模型缓存"><a href="#异步图像-使用模型缓存" class="headerlink" title="异步图像-使用模型缓存"></a>异步图像-使用模型缓存</h2><h3 id="目标-1"><a href="#目标-1" class="headerlink" title="目标"></a>目标</h3><ul>
<li>使用模型缓存网络图像</li>
</ul>
<h3 id="操作步骤-1"><a href="#操作步骤-1" class="headerlink" title="操作步骤"></a>操作步骤</h3><ul>
<li>在模型中添加图像缓存属性</li>
</ul>
<blockquote>
<p>注意需要导入<uikit uikit.h="">头文件</uikit></p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;UIKit/UIKit.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AppInfo</span> : <span class="title">NSObject</span></span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *download;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *icon;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="built_in">UIImage</span> *imageCache;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<ul>
<li>修改数据源方法</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">-(<span class="built_in">UITableViewCell</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath&#123;</div><div class="line">    </div><div class="line">    AppCell *cell = [tableView dequeueReusableCellWithIdentifier:cellID forIndexPath:indexPath];</div><div class="line">    </div><div class="line">    AppInfo *info = <span class="keyword">self</span>.app_infos[indexPath.row];</div><div class="line">    </div><div class="line">    cell.appName.text = info.name;</div><div class="line">    cell.downCount.text = info.download;</div><div class="line">    <span class="comment">//在这里设置占位图像 用来解决图像闪动的问题</span></div><div class="line">    cell.iconView.image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"user_default"</span>];</div><div class="line">    </div><div class="line">    <span class="comment">//判断是否在模型中已经有缓存 如果有 将图片设置好后直接return cell;</span></div><div class="line">    <span class="keyword">if</span> (info.imageCache != <span class="literal">nil</span>) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"从模型缓存中取图片"</span>);</div><div class="line">        cell.iconView.image = info.imageCache;</div><div class="line">        <span class="keyword">return</span> cell;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="keyword">self</span>.app_infos[indexPath.row].icon];</div><div class="line">    </div><div class="line">    <span class="built_in">NSBlockOperation</span> *op = [<span class="built_in">NSBlockOperation</span>  blockOperationWithBlock:^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"正在下载 %@ 的图片"</span>, <span class="keyword">self</span>.app_infos[indexPath.row].name);</div><div class="line">        <span class="comment">//在这里加入模拟网络延迟的代码</span></div><div class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">0.5</span>];</div><div class="line">        </div><div class="line">        <span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfURL:url];</div><div class="line">        <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageWithData:data];</div><div class="line">        </div><div class="line">        <span class="comment">//在这里将图像存入模型缓存</span></div><div class="line">        info.imageCache = image;</div><div class="line">        </div><div class="line">        <span class="comment">//在主线程中更新UI</span></div><div class="line">        [[<span class="built_in">NSOperationQueue</span> mainQueue] addOperationWithBlock:^&#123;</div><div class="line">            cell.iconView.image = image;</div><div class="line">        &#125;];</div><div class="line">    &#125;];</div><div class="line">    </div><div class="line">    <span class="comment">//将操作加入下载队列</span></div><div class="line">    [<span class="keyword">self</span>.downloadQueque addOperation:op];</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> cell;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>存在问题</p>
<ul>
<li>如果出现内存警告, 内存清理工作将变得繁琐且不符合逻辑</li>
<li>一旦cell复用, 仍然会重新下载<br><img src="http://d.pr/i/MBha+" alt="重新下载的复现"></li>
<li>解决办法: 单独管理图像缓存</li>
</ul>
</blockquote>
<h2 id="异步图像-使用字典进行缓存"><a href="#异步图像-使用字典进行缓存" class="headerlink" title="异步图像-使用字典进行缓存"></a>异步图像-使用字典进行缓存</h2><h3 id="目标-2"><a href="#目标-2" class="headerlink" title="目标"></a>目标</h3><ul>
<li>使用字典缓存已经下载好的图像</li>
</ul>
<h3 id="操作步骤-2"><a href="#操作步骤-2" class="headerlink" title="操作步骤"></a>操作步骤</h3><ul>
<li>恢复模型 将之前设置的缓存图像属性删除</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AppInfo</span> : <span class="title">NSObject</span></span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *download;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *icon;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<ul>
<li>在<code>viewController</code>中定义字典缓存属性</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableDictionary</span> *imageCacheDict;</div></pre></td></tr></table></figure>
<ul>
<li>懒加载字典缓存</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">-(<span class="built_in">NSMutableDictionary</span> *)imageCacheDict&#123;</div><div class="line">    <span class="keyword">if</span> (_imageCacheDict == <span class="literal">nil</span>) &#123;</div><div class="line">        _imageCacheDict = [<span class="built_in">NSMutableDictionary</span> dictionary];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> _imageCacheDict;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>修改数据源方法, 判断缓存图像是否已经存在</li>
<li>如果缓存不存在, 则下载图像, 并添加到字典缓存中</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">-(<span class="built_in">UITableViewCell</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath&#123;</div><div class="line">    </div><div class="line">    AppCell *cell = [tableView dequeueReusableCellWithIdentifier:cellID forIndexPath:indexPath];</div><div class="line">    </div><div class="line">    AppInfo *info = <span class="keyword">self</span>.app_infos[indexPath.row];</div><div class="line">    </div><div class="line">    cell.appName.text = info.name;</div><div class="line">    cell.downCount.text = info.download;</div><div class="line">    <span class="comment">//在这里设置占位图像 用来解决图像闪动的问题</span></div><div class="line">    cell.iconView.image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"user_default"</span>];</div><div class="line">    </div><div class="line">    <span class="comment">//判断图像是否已经被缓存</span></div><div class="line">    <span class="comment">//如果缓存 则直接将缓存中的图像显示在iconView上</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.imageCacheDict[info.icon] != <span class="literal">nil</span>) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@ 的图像已经从字典缓存中取出"</span>, info.name);</div><div class="line">        cell.iconView.image = <span class="keyword">self</span>.imageCacheDict[info.icon];</div><div class="line">        <span class="keyword">return</span> cell;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.operationCacheDict[info.icon] != <span class="literal">nil</span>) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@ is downloading"</span>, info.name);</div><div class="line">        <span class="keyword">return</span> cell;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="keyword">self</span>.app_infos[indexPath.row].icon];</div><div class="line">    </div><div class="line">    <span class="built_in">NSBlockOperation</span> *op = [<span class="built_in">NSBlockOperation</span>  blockOperationWithBlock:^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"正在下载 %@ 的图片"</span>, <span class="keyword">self</span>.app_infos[indexPath.row].name);</div><div class="line">        <span class="comment">//在这里加入模拟网络延迟的代码</span></div><div class="line">        <span class="comment">//模拟下载环境有随机延迟 可以看到有操作被重复添加了</span></div><div class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:arc4random_uniform(<span class="number">10</span>)];</div><div class="line">        </div><div class="line">        <span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfURL:url];</div><div class="line">        <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageWithData:data];</div><div class="line">        </div><div class="line">        <span class="comment">//在主线程中更新UI</span></div><div class="line">        [[<span class="built_in">NSOperationQueue</span> mainQueue] addOperationWithBlock:^&#123;</div><div class="line">            <span class="comment">//查看已经存在的操作数量</span></div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"操作的数量: %ld"</span>, <span class="keyword">self</span>.downloadQueque.operationCount);</div><div class="line">            </div><div class="line">            <span class="comment">//添加到图像字典缓存中</span></div><div class="line">            <span class="comment">//注意!! 字典value不能为nil</span></div><div class="line">            <span class="keyword">if</span> (image != <span class="literal">nil</span>) &#123;</div><div class="line">                [<span class="keyword">self</span>.imageCacheDict setValue:image forKey:info.icon];</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            cell.iconView.image = image;</div><div class="line">        &#125;];</div><div class="line">    &#125;];</div><div class="line">    </div><div class="line">    <span class="comment">//将操作加入下载队列</span></div><div class="line">    [<span class="keyword">self</span>.downloadQueque addOperation:op];</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> cell;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>注意: 使用模型的icon属性, 可以避免缓存图像重名的问题</p>
</blockquote>
<h3 id="实现内存警告方法"><a href="#实现内存警告方法" class="headerlink" title="实现内存警告方法"></a>实现内存警告方法</h3><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#pragma</span> <span class="selector-tag">mark</span> <span class="selector-tag">-</span> <span class="selector-tag">memory</span> <span class="selector-tag">Warning</span></div><div class="line"></div><div class="line"><span class="selector-tag">-</span>(void)<span class="selector-tag">didReceiveMemoryWarning</span>&#123;</div><div class="line">    <span class="selector-attr">[super didReceiveMemoryWarning]</span>;</div><div class="line">    <span class="selector-attr">[self.imageCacheDict removeAllObjects]</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>运行测试<br><img src="http://d.pr/i/wyGJ+" alt="测试"><br>如果某一个下载操作耗时较长, 当用户快速拖拽表单时, 下载操作会被重复创建!</p>
</blockquote>
<h3 id="测试重复创建操作的现象"><a href="#测试重复创建操作的现象" class="headerlink" title="测试重复创建操作的现象"></a>测试重复创建操作的现象</h3><ul>
<li>设置下载的模拟延迟略长一些, 并快速拖动表单<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"正在下载 %@ 的图片"</span>, <span class="keyword">self</span>.app_infos[indexPath.row].name);</div><div class="line"><span class="comment">//在这里加入模拟网络延迟的代码</span></div><div class="line"><span class="comment">//模拟下载环境有随机延迟 可以看到有操作被重复添加了</span></div><div class="line">[<span class="built_in">NSThread</span> sleepForTimeInterval:arc4random_uniform(<span class="number">10</span>)];</div></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>如下图, 总共只有16张图片, 却添加了21个下载操作!<br><img src="http://d.pr/i/7p3P+" alt="测试"></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[模拟SDWebImage异步下载图片操作(一)]]></title>
      <url>http://yoursite.com/2016/07/30/%E6%A8%A1%E6%8B%9FSDWebImage%E5%BC%82%E6%AD%A5%E4%B8%8B%E8%BD%BD%E5%9B%BE%E7%89%87%E6%93%8D%E4%BD%9C(%E4%B8%80)/</url>
      <content type="html"><![CDATA[<p><img src="http://ww4.sinaimg.cn/large/6b1763dbjw1f6c5lbhtm5j21kw2aytxa.jpg" alt="思维导图"></p>
<h2 id="异步下载图片操作-搭建界面"><a href="#异步下载图片操作-搭建界面" class="headerlink" title="异步下载图片操作-搭建界面"></a>异步下载图片操作-搭建界面</h2><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><ul>
<li>搭建界面</li>
<li>体会<code>AFNetWoring</code>的使用</li>
<li>复习<code>tableView</code>的简单实用</li>
</ul>
<h3 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h3><h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><ul>
<li>新建项目</li>
<li>将<code>Main.storyboard</code>中初始的<code>ViewController</code>删除, 并在其中拖入一个包装着<code>NavigationController</code>的<code>TableviewController</code></li>
<li>将<code>storyboard</code>中的<code>TableView</code> 绑定为系统的<code>viewController</code>类 并将系统自带的<code>viewController</code>继承自<code>UITableViewController</code>类<blockquote>
<p>运行测试<br><img src="http://d.pr/i/1dUJF+" alt="Cell界面搭建"></p>
</blockquote>
</li>
</ul>
<h4 id="加载网络数据"><a href="#加载网络数据" class="headerlink" title="加载网络数据"></a>加载网络数据</h4><ul>
<li>添加<code>AFNetWorking</code>网络框架</li>
<li>导入头文件</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#import</span> <span class="string">"AFNetworking.h"</span></div></pre></td></tr></table></figure>
<ul>
<li>实现loadData方法</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">-(<span class="keyword">void</span>)loadData &#123;</div><div class="line">    <span class="built_in">NSString</span> *urlString = <span class="string">@"https://raw.githubusercontent.com/massacreformash/DemoRepository/master/apps.json"</span>;</div><div class="line">    </div><div class="line">    <span class="comment">//初始化一个网络请求的管理器</span></div><div class="line">    AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];</div><div class="line">    </div><div class="line">    [manager GET:urlString parameters:<span class="literal">nil</span> progress:<span class="literal">nil</span> success:^(<span class="built_in">NSURLSessionDataTask</span> * _Nonnull task, <span class="keyword">id</span>  _Nullable responseObject) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"success: %@"</span>, responseObject);</div><div class="line">    &#125; failure:^(<span class="built_in">NSURLSessionDataTask</span> * _Nullable task, <span class="built_in">NSError</span> * _Nonnull error) &#123;</div><div class="line">        <span class="comment">//在公司开发的话 错误请求一定要处理</span></div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"fail: %@"</span>, error);</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>运行测试 此时在控制台应该能够看到类似于这样的输出:<br><img src="http://d.pr/i/1e5R7+" alt="输出"></p>
</blockquote>
<h4 id="绑定表格数据"><a href="#绑定表格数据" class="headerlink" title="绑定表格数据"></a>绑定表格数据</h4><ul>
<li>定义tableView可重用标识符</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> *cellId = <span class="string">@"cellid"</span>;</div></pre></td></tr></table></figure>
<ul>
<li>设置数据源并注册原型cell</li>
<li>遵守协议</li>
</ul>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@interface</span> ViewController () <span class="variable">&lt;UITableViewDataSource&gt;</span></div></pre></td></tr></table></figure>
<ul>
<li>实现协议方法</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#pragma mark - 数据源方法</span></div><div class="line"></div><div class="line">-(<span class="built_in">NSInteger</span>)tableView:(<span class="built_in">UITableView</span> *)tableView numberOfRowsInSection:(<span class="built_in">NSInteger</span>)section&#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">10</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">-(<span class="built_in">UITableViewCell</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath&#123;</div><div class="line">    <span class="built_in">UITableViewCell</span> *cell = [tableView dequeueReusableCellWithIdentifier:cellId forIndexPath:indexPath];</div><div class="line">    cell.textLabel.text = @(indexPath.row).description;</div><div class="line">    <span class="keyword">return</span> cell;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p><img src="http://d.pr/i/D2IP+" alt="测试"></p>
</blockquote>
<h4 id="定义模型"><a href="#定义模型" class="headerlink" title="定义模型"></a>定义模型</h4><ul>
<li>新建<code>AppInfo</code>模型 继承自<code>NSObject</code> 并声明好相关属性</li>
</ul>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="variable">@interface</span> <span class="attribute">AppInfo </span>: NSObject</div><div class="line"></div><div class="line"><span class="variable">@property</span> (nonatomic, copy) NSString *name;</div><div class="line"><span class="variable">@property</span> (nonatomic, copy) NSString *download;</div><div class="line"><span class="variable">@property</span> (nonatomic, copy) NSString *icon;</div><div class="line"></div><div class="line"><span class="variable">@end</span></div></pre></td></tr></table></figure>
<ul>
<li>在viewController中导入模型 并设置模型数组</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"AppInfo.h"</span></span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableArray</span> &lt;AppInfo *&gt; *app_infos;</div></pre></td></tr></table></figure>
<ul>
<li>懒加载<code>app_infos</code></li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">-(<span class="built_in">NSMutableArray</span> *)app_infos&#123;</div><div class="line">    <span class="keyword">if</span> (_app_infos == <span class="literal">nil</span>) &#123;</div><div class="line">        _app_infos = [<span class="built_in">NSMutableArray</span> array];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> _app_infos;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>修改<code>loadData</code>方法 在其中将下载好的字典转为模型</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">-(<span class="keyword">void</span>)loadData &#123;</div><div class="line">    </div><div class="line">    <span class="built_in">NSString</span> *urlString = <span class="string">@"https://raw.githubusercontent.com/massacreformash/DemoRepository/master/apps.json"</span>;</div><div class="line">    </div><div class="line">    <span class="comment">//初始化一个网络请求的管理器</span></div><div class="line">    AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];</div><div class="line">    </div><div class="line">    [manager GET:urlString parameters:<span class="literal">nil</span> progress:<span class="literal">nil</span> success:^(<span class="built_in">NSURLSessionDataTask</span> * _Nonnull task, <span class="keyword">id</span>  _Nullable responseObject) &#123;</div><div class="line">        <span class="comment">//字典转模型</span></div><div class="line">        <span class="built_in">NSArray</span> *array = responseObject;</div><div class="line">        <span class="keyword">for</span> (<span class="built_in">NSDictionary</span> *dict <span class="keyword">in</span> array) &#123;</div><div class="line">            AppInfo *info = [[AppInfo alloc] init];</div><div class="line">            [info setValuesForKeysWithDictionary:dict];</div><div class="line">            [<span class="keyword">self</span>.app_infos addObject:info];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">//刷新tableView</span></div><div class="line">        [<span class="keyword">self</span>.tableView reloadData];</div><div class="line">    &#125; failure:^(<span class="built_in">NSURLSessionDataTask</span> * _Nullable task, <span class="built_in">NSError</span> * _Nonnull error) &#123;</div><div class="line">        <span class="comment">//在公司开发的话 错误请求一定要处理</span></div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"fail: %@"</span>, error);</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>得到类似如下数据:<br><img src="http://d.pr/i/1kt4z+" alt="测试"></p>
</blockquote>
<ul>
<li>修改数据源方法, 绑定cell数据</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#pragma mark - 数据源方法</span></div><div class="line"></div><div class="line">-(<span class="built_in">NSInteger</span>)tableView:(<span class="built_in">UITableView</span> *)tableView numberOfRowsInSection:(<span class="built_in">NSInteger</span>)section&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.app_infos.count;</div><div class="line">&#125;</div><div class="line"></div><div class="line">-(<span class="built_in">UITableViewCell</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath&#123;</div><div class="line">    <span class="built_in">UITableViewCell</span> *cell = [tableView dequeueReusableCellWithIdentifier:<span class="string">@"cell"</span> forIndexPath:indexPath];</div><div class="line">    </div><div class="line">    AppInfo *info = <span class="keyword">self</span>.app_infos[indexPath.row];</div><div class="line">    cell.textLabel.text = info.name;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>进行测试<br><img src="http://d.pr/i/27pF+" alt="测试"></p>
</blockquote>
<h2 id="异步下载图片操作-设置图像"><a href="#异步下载图片操作-设置图像" class="headerlink" title="异步下载图片操作-设置图像"></a>异步下载图片操作-设置图像</h2><h3 id="目标-1"><a href="#目标-1" class="headerlink" title="目标"></a>目标</h3><ul>
<li>使用<code>SDWebImage</code>异步加载网络图像</li>
<li>在storyboard中自定义Cell</li>
</ul>
<h3 id="操作步骤-1"><a href="#操作步骤-1" class="headerlink" title="操作步骤"></a>操作步骤</h3><h4 id="使用SDWebImage加载图像"><a href="#使用SDWebImage加载图像" class="headerlink" title="使用SDWebImage加载图像"></a>使用<code>SDWebImage</code>加载图像</h4><ul>
<li>导入<code>SDWebImage</code>框架</li>
<li>导入头文件</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#import</span> <span class="string">"UIImageView+WebCache.h"</span></div></pre></td></tr></table></figure>
<ul>
<li>修改数据源方法</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (UITableViewCell *)<span class="string">tableView:</span>(UITableView *)tableView <span class="string">cellForRowAtIndexPath:</span>(NSIndexPath *)indexPath &#123;</div><div class="line"></div><div class="line">    UITableViewCell *cell = [tableView <span class="string">dequeueReusableCellWithIdentifier:</span>cellId <span class="string">forIndexPath:</span>indexPath];</div><div class="line"></div><div class="line">    AppInfo *info = self.app_infos[indexPath.row];</div><div class="line">    cell.textLabel.text = info.name;</div><div class="line"></div><div class="line">    <span class="comment">//SDWebImage</span></div><div class="line">    [cell.imageView <span class="string">sd_setImageWithURL:</span>[NSURL <span class="string">URLWithString:</span>info.icon]];</div><div class="line"></div><div class="line">    <span class="keyword">return</span> cell;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>在info.plist增加ATS设置<br><img src="http://d.pr/i/15K3N+" alt="设置ATS"><br>运行测试</p>
<ul>
<li>图像需要点击之后才能显示<br><img src="http://d.pr/i/XTsf+" alt="测试"></li>
<li>因为图像加载是异步的, 第一次设置数据源方法时, 图像还没有下载完成, 那么系统默认的<code>tableViewCell</code>也不会创建图像视图<br>解决办法: 用自定义的Cell</li>
</ul>
</blockquote>
<h4 id="自定义Cell"><a href="#自定义Cell" class="headerlink" title="自定义Cell"></a>自定义Cell</h4><ul>
<li>新建自定义的<code>AppCell</code>继承自<code>UITableviewCell</code>, 同时将Tableview的Cell绑定到<code>AppCell</code>类</li>
<li>设置自动布局</li>
</ul>
<p><img src="http://d.pr/i/18u4U+" alt="Cell界面搭建"></p>
<ul>
<li>代码连线到头文件中</li>
</ul>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="variable">@interface</span> <span class="attribute">AppCell </span>: UITableViewCell</div><div class="line"></div><div class="line"><span class="variable">@property</span> (weak, nonatomic) IBOutlet UIImageView *iconView;</div><div class="line"><span class="variable">@property</span> (weak, nonatomic) IBOutlet UILabel *appName;</div><div class="line"><span class="variable">@property</span> (weak, nonatomic) IBOutlet UILabel *downCount;</div><div class="line"></div><div class="line"><span class="variable">@end</span></div></pre></td></tr></table></figure>
<h4 id="修改控制器的代码"><a href="#修改控制器的代码" class="headerlink" title="修改控制器的代码"></a>修改控制器的代码</h4><ul>
<li>导入头文件</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#import</span> <span class="string">"AppCell.h"</span></div></pre></td></tr></table></figure>
<ul>
<li>修改可重用cell为自定义cell</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">AppCell *cell = [tableView <span class="string">dequeueReusableCellWithIdentifier:</span>cellID <span class="string">forIndexPath:</span>indexPath];</div></pre></td></tr></table></figure>
<ul>
<li>修改数据源方法</li>
</ul>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">-(UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123;</div><div class="line">    </div><div class="line">    AppCell *cell = [tableView dequeueReusableCellWithIdentifier:cellID forIndexPath:indexPath]<span class="comment">;</span></div><div class="line">    </div><div class="line">    AppInfo *info = self.app_infos[indexPath.row]<span class="comment">;</span></div><div class="line">    </div><div class="line">    cell.appName<span class="meta">.text</span> = info.name<span class="comment">;</span></div><div class="line">    cell.downCount<span class="meta">.text</span> = info.download<span class="comment">;</span></div><div class="line">    [cell.iconView sd_setImageWithURL:[NSURL URLWithString:info.icon]]<span class="comment">;</span></div><div class="line">    </div><div class="line">    return cell<span class="comment">;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>运行测试<br><img src="http://d.pr/i/1hGr7+" alt="测试"></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[GCD 使用手册(二)]]></title>
      <url>http://yoursite.com/2016/05/13/GCD%20%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C(%E4%BA%8C)/</url>
      <content type="html"><![CDATA[<blockquote>
<p>接上篇</p>
</blockquote>
<h3 id="等待多个并发任务完成"><a href="#等待多个并发任务完成" class="headerlink" title="等待多个并发任务完成"></a>等待多个并发任务完成</h3><blockquote>
<p>如果我们有多个等待执行的block, 而且又需要关注这个block集合的完成, 就可以使用<code>group</code>. <code>dispatch_group_async</code>方法可以使你将任务添加到队列中(这些任务应该是异步的), 并且它可以持续追踪有多少任务被添加. 需要注意的是相同的动作可以向不同的队列中添加任务并且都能够进行跟踪. 当所有被跟踪的任务都完成时, 整个调度组会激活<code>dispatch_group_notify</code>方法, 就像是一种完成回调block一样.</p>
</blockquote>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">dispatch_group_t <span class="keyword">group</span> = dispatch_group_create()</div><div class="line"><span class="keyword">for</span> <span class="literal">item</span> <span class="keyword">in</span> someArray &#123;</div><div class="line">	dispatch_group_async(group, backgroundQueue, &#123;</div><div class="line">		performExpensiveWork(item: item)</div><div class="line">	&#125;)</div><div class="line">&#125;</div><div class="line">dispatch_group_notify(<span class="keyword">group</span>, dispatch_get_main_queue(), &#123;</div><div class="line">	// all the work is complete</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>对于有完成回调block的方法来说, 这是一个绝佳的解耦技巧. GCD 调度组在返回时会考虑其中的任务是否已经完成, 所以我们需要一个block来等待调度组中的任务完成.</li>
<li>下面是一种手动调用 GCD 调度组的应用, 特别是当我们的耗时操作已经是异步的时候.</li>
</ul>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// must be on a background thread</span></div><div class="line">dispatch_group_t <span class="keyword">group</span> = dispatch_group_create()</div><div class="line"><span class="keyword">for</span> item <span class="keyword">in</span> someArray &#123;</div><div class="line">	dispatch_group_enter(<span class="keyword">group</span>)</div><div class="line">	performExpensiveAsyncWork(item: item, completionBlock: &#123;</div><div class="line">		dispatch_group_leave(<span class="keyword">group</span>)</div><div class="line">	&#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">dispatch_group_wait(<span class="keyword">group</span>, DISPATCH_TIME_FOREVER)</div><div class="line"></div><div class="line"><span class="comment">// all the work is complete</span></div></pre></td></tr></table></figure>
<ul>
<li>这个代码片段有些复杂, 但是逐行探究的话可以帮助我们理解它. 就像是<br>信号量一样, 调度组可以保持一个线程安全的内部计数器, 来供我们操作. 我们可以使用这个计数器来保证在我们调用完成回调的 block 前, 耗时任务已经全部完成. 使用<code>enter</code>会使计数器自增, 而<code>leave</code>则会使计数器自减. <code>dispatch_group_async</code>方法会替我们处理其中的细节, 所以有可能的话我更推荐使用这种方法.</li>
<li>在这个代码片段中, 最后需要注意的是<code>wait</code>的调用: 它会阻塞这个线程, 直到计数器为0. 另外就算我们手动调用了<code>enter</code>/<code>leave</code>的 APIs, 我们也可以使用<code>dispatch_group_notify</code>来监听耗时操作完成. 反过来也是同样的, 使用<code>dispatch_group_async</code> API时, 也可以使用<code>dispatch_group_wait</code>方法.</li>
<li><code>dispatch_group_wait</code>, 就像<code>dispatch_semaphore_wait</code>一样, 也允许传入一个超时时间. 再次强调的是, 这个方法中的参数, 我从来没有除了传入<code>DISPATCH_TIME_FOREVER</code>参数以外的需求. 与<code>dispatch_semaphore_wait</code>一样, 在主线程中, 不要调用<code>dispatch_group_wait</code>方法.</li>
<li>在这两种写法中最大的不同是, 使用<code>notify</code>的例子完全可以在主线程中被调用, 而使用<code>wait</code>的例子则必须在后台线程被调用(至少是带有<code>wait</code>的那部分代码, 因为这会完全阻塞当前线程).</li>
</ul>
<h3 id="隔离队列"><a href="#隔离队列" class="headerlink" title="隔离队列"></a>隔离队列</h3><blockquote>
<p>Swift 中的<code>Dictionary</code>(和<code>Array</code>)类型都是值类型. 当它们被定义时, 它们的引用就完全被这个结构的新拷贝替换了. 然而, 由于更新实例变量在 Swift 中是非原子性的, 也就是说是非线程安全的. 两个线程可以同时对一个字典进行操作(举例来说, 加入一个值), 并且都可以尝试对同一个内存区块进行写入, 而这则将导致内存崩溃. 此时我们可以使隔离队列来达到线程安全的目的.<br><br><br><br>我们来创建一个 <a href="http://martinfowler.com/eaaCatalog/identityMap.html" target="_blank" rel="external">恒等映射</a>. 一个恒等映射相当于使用字典将 model 对象与它的 ID 一一映射起来.</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">IdentityMap</span>&lt;<span class="title">T</span>: <span class="title">Identifiable</span>&gt; </span>&#123;</div><div class="line">	<span class="keyword">var</span> dictionary = <span class="type">Dictionary</span>&lt;<span class="type">String</span>, <span class="type">T</span>&gt;()</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">func</span> <span class="title">object</span><span class="params">(forID ID: String)</span></span> -&gt; <span class="type">T</span>? &#123;</div><div class="line">		<span class="keyword">return</span> dictionary[<span class="type">ID</span>] <span class="keyword">as</span> <span class="type">T</span>?</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">func</span> <span class="title">addObject</span><span class="params">(object: T)</span></span> &#123;</div><div class="line">		dictionary[object.<span class="type">ID</span>] = object</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>这个类主要作用是将一个字典包装起来. 如果其中的<code>addObject</code>方法同时被多个线程调用, 那就会使内存崩溃, 因为这些线程同时操作了同一个引用. 这是一个典型的 <a href="https://en.wikipedia.org/wiki/Readers%E2%80%93writers_problem" target="_blank" rel="external">读者-写者问题</a>. 简要地说, 我们可以有多个线程同时读取, 但却必须保证在给定的时间内只有一个线程可以写入.</li>
<li>幸运的是, 针对这个应用场景, GCD 给了我们一个很好的工具来解决. 我们需要四个 API 来解决这个问题:<ul>
<li><code>dispatch_sync</code></li>
<li><code>dispatch_async</code></li>
<li><code>dispatch_barrier_sync</code></li>
<li><code>dispatch_barrier_async</code></li>
</ul>
</li>
<li>我们的理想情况是, 读取操作是异步并发的, 同时写入操作可以是异步的, 但在同一时间内必须是针对某一引用的唯一操作. GCD 中<code>barrier</code>系列的 API 可以做到一些特别的效果: 它们可以等待操作队列完全变空后才执行后面的block. 在写入操作中使用<code>barrier</code>系列的的 API 可以限制对字典的访问, 并且保证在进行读取或写入操作时, 不会有另一个写入的操作并发.</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">IdentityMap</span>&lt;<span class="title">T</span>: <span class="title">Identifiable</span>&gt; </span>&#123;</div><div class="line">	<span class="keyword">var</span> dictionary = <span class="type">Dictionary</span>&lt;<span class="type">String</span>, <span class="type">T</span>&gt;()</div><div class="line">	<span class="keyword">let</span> accessQueue = dispatch_queue_create(<span class="string">"com.khanlou.isolation.queue"</span>, <span class="type">DISPATCH_QUEUE_CONCURRENT</span>)</div><div class="line">	    </div><div class="line">	<span class="function"><span class="keyword">func</span> <span class="title">object</span><span class="params">(withID ID: String)</span></span> -&gt; <span class="type">T</span>? &#123;</div><div class="line">		<span class="keyword">var</span> result: <span class="type">T</span>? = <span class="literal">nil</span></div><div class="line">		dispatch_sync(accessQueue, &#123;</div><div class="line">			result = dictionary[<span class="type">ID</span>] <span class="keyword">as</span> <span class="type">T</span>?</div><div class="line">		&#125;)</div><div class="line">		<span class="keyword">return</span> result</div><div class="line">	&#125;</div><div class="line">	    </div><div class="line">	<span class="function"><span class="keyword">func</span> <span class="title">addObject</span><span class="params">(object: T)</span></span> &#123;</div><div class="line">		dispatch_barrier_async(accessQueue, &#123;</div><div class="line">			dictionary[object.<span class="type">ID</span>] = object</div><div class="line">		&#125;)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>dispatch_sync</code>会将 block 放入我们的隔离队列中, 并且等待其中的任务执行完毕后再返回. 这样, 我们就有了同步读取操作的返回值(如果我们没有使用同步, 那么我们的 getter 就需要一个完成回调的 block 了). 由于<code>accessQueue</code>是并发的, 这些同步的读取任务可以被同时执行.</li>
<li><code>dispatch_barrier_async</code>方法会将 block 放入我们的隔离队列中, <code>async</code>意味着其会在 block 中的操作(就是我们定义的写入操作)完成前返回, 这意味着我们可以继续处理后面的任务.</li>
<li><code>dispatch_barrier_async</code>方法中的<code>barrier</code>则代表着其会等待队列中所有已存在的任务都完成后, 才执行自己的 block. 而在其后面入队的 block 则会等待这个<code>barrier</code>任务执行完成后才继续执行.</li>
</ul>
<h3 id="取消-block"><a href="#取消-block" class="headerlink" title="取消 block"></a>取消 block</h3><blockquote>
<p>GCD 一个不为人知的小功能是 block 其实是可以被取消的. 将一个 block 包装进<code>dispatch_block_t</code>中, 再调用<code>dispatch_block_cancel</code> API, 就可以取消了.</p>
</blockquote>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> work = dispatch_block_create(<span class="number">0</span>) &#123; print(<span class="string">"Hello!"</span>) &#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> delayTime = dispatch_time(DISPATCH_TIME_NOW, Int64(<span class="number">10</span> * Double(NSEC_PER_SEC)))</div><div class="line"><span class="function"><span class="title">dispatch_after</span><span class="params">(delayTime, dispatch_get_main_queue(), work)</span></span></div><div class="line"></div><div class="line"><span class="title">dispatch_block_cancel</span><span class="params">(work)</span></div></pre></td></tr></table></figure>
<ul>
<li>在这个 block 开始执行时, 是不能被取消的. 这是符合常理的, 因为队列并不知道我们的 block 内部究竟执行了什么代码, 或者如何去取消它. 我们可以用<code>dispatch_block_testcancel</code>在 block 内部写一个自己的检查器:</li>
</ul>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> work: dispatch_block_t</div><div class="line">work = dispatch_block_create(DISPATCH_BLOCK_INHERIT_QOS_CLASS, &#123;</div><div class="line">    expensiveWorkPart1()</div><div class="line">    <span class="function">guard <span class="title">dispatch_block_testcancel</span>(<span class="params">work</span>) </span>== <span class="number">0</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</div><div class="line">    expensiveWorkPart2()</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<ul>
<li>这个操作很像是在<code>NSOperation</code>中去检测<code>isCancelled</code>属性, 需要注意的是我们需要在第一步事先声明好一个<code>work</code>变量, 哪怕是我们不先初始化它. 这么做是因为我们需要在 block <strong>内部</strong>使用这个<code>work</code>变量, 而 Swift 是不允许我们内联调用的.</li>
<li>(ps: <code>dispatch_block_testcancel</code>? 这是哪位大神命名的 API…)</li>
</ul>
<p>未完待续……</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[GCD 使用手册(一)]]></title>
      <url>http://yoursite.com/2016/05/08/GCD%20%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C(%E4%B8%80)/</url>
      <content type="html"><![CDATA[<ul>
<li>注: 在网上看到了这篇文章的翻译, 实在是错漏太多, 而且极不通顺. 所以自己准备着手翻译一遍, 原文地址在下面附上</li>
<li><a href="">http://khanlou.com/2016/04/the-GCD-handbook/</a></li>
</ul>
<blockquote>
<p><code>Grand Central Dispatch</code>, 或者说<code>GCD</code>, 是一个非常有力的工具. 它向我们提供了一些底层的组件, 像是<code>队列</code>或是<code>信号量</code>等这些组件, 可以让我们通过有趣的排列组合方式达到多线程的效果. 但不幸的是, 这个 C 语言为底层的 API 框架有一些晦涩难懂, 并且没有一些明显的提示能够告诉我们如何将这些底层的框架组合成为实际的应用场景</p>
<p>在这篇文章中, 我希望能将一些常见的应用场景通过<code>GCD</code>的API向大家呈现</p>
</blockquote>
<h3 id="后台线程"><a href="#后台线程" class="headerlink" title="后台线程"></a>后台线程</h3><blockquote>
<p>后台线程有可能是最简单的应用场景了, 这可以让我们在后台的线程中执行一些代码, 并返回到主线程继续处理(像是<code>UIKit</code>中的一些组件, 必须在主线程中进行操作)</p>
<p><strong>在这个教程中, 我会使用类似于<code>doSomeExpensiveWork()</code>这样的方法, 来表示耗时操作(耗时操作: 即我们应该放在异步中执行的方法, 防止主线程被阻塞)</strong></p>
</blockquote>
<ul>
<li>这个模式可以以下面的代码来实现</li>
</ul>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">let defaultPriority = DISPATCH_QUEUE_PRIORITY_DEFAULT</div><div class="line">let backgroundQueue = dispatch_get_global_queue(<span class="name">defaultPriority</span>, <span class="number">0</span>)</div><div class="line">dispatch_async(<span class="name">backgroundQueue</span>, &#123;</div><div class="line">	let result = doSomeExpensiveWork()</div><div class="line">	dispatch_async(<span class="name">dispatch_get_main_queue</span>(), &#123;</div><div class="line">		//use `result` somehow</div><div class="line">	&#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<ul>
<li>在实际应用中, 除了<code>DISPATCH_QUEUE_PRIORITY_DEFAULT</code>我没有用过其他队列的优先级. <code>dispatch_get_global_queue(defaultPriority, 0)</code>这个方法会返回一个全局队列, 可以将上百个线程放在后台中进行操作.</li>
<li>如果我们需要将耗时操作放在一个一个特定的队列中执行, 我们可以使用<code>dispatch_queue_create</code>方法创建自己的队列. <code>dispatch_queue_create</code>这个方法可以让我们自行给队列命名(而非返回一个唯一的<code>全局队列</code>), 并且可以选择所创建的队列是串行队列还是并行队列</li>
<li>需要注意的是, 每一次调用使用的都是<code>dispatch_async</code>操作, 而不是<code>dispatch_sync</code>操作(注: async即asynchronous: 异步操作, sync即synchronous: 同步操作). <code>dispatch_async</code>会在block执行完毕前就返回, 并且执行下面的代码, 但<code>dispatch_sync</code>则会等待block中的代码执行完毕后才会返回. The inner call can use dispatch_sync (because it doesn’t matter when it returns), but the outer call must be dispatch_async (otherwise the main thread will be blocked).</li>
</ul>
<h3 id="创建单例"><a href="#创建单例" class="headerlink" title="创建单例"></a>创建单例</h3><blockquote>
<p><code>dispatch_once</code>这个 API 可以用来创建单例. 在 Swift 中这已经不是必须的了, 因为在 Swift 中存在一种更简单的方式来创建单例(注: 即可以通过<code>static let</code>实现). 不过在 OBjective-C 中, 这个方式还是可以供后来人参考的</p>
</blockquote>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">+ (<span class="keyword">instancetype) </span><span class="keyword">sharedInstance </span>&#123;  </div><div class="line">	static <span class="keyword">dispatch_once_t </span>onceToken<span class="comment">;  </span></div><div class="line">	static id <span class="keyword">sharedInstance; </span> </div><div class="line">	<span class="keyword">dispatch_once(&amp;onceToken, </span>^&#123;  </div><div class="line">		<span class="keyword">sharedInstance </span>= [[self alloc] init]<span class="comment">;  </span></div><div class="line">	&#125;)<span class="comment">;  </span></div><div class="line">	return <span class="keyword">sharedInstance; </span> </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="block调用的串行化"><a href="#block调用的串行化" class="headerlink" title="block调用的串行化"></a>block调用的串行化</h3><blockquote>
<p>从这里开始, GCD 这种机制开始变的有趣起来了. 使用<code>信号量</code>, 我们可以将某一个线程阻塞任意时间, 知道另一个线程发出信号. <code>信号量(Semaphore)</code>, 就像 GCD 中其它的组件一样, 是线程安全的, 并且可以在任意地方触发.<br><br><br><br>信号量可以被用作当我们需要将一个异步操作转变为同步操作, 而又无法修改该操作时的一种方法</p>
</blockquote>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// on a background queue</div><div class="line">dispatch_semaphore_t semaphore = dispatch_semaphore_create(<span class="number">0</span>)</div><div class="line">doSomeExpensiveWorkAsynchronously(<span class="name">completionBlock</span>: &#123;</div><div class="line">    dispatch_semaphore_signal(<span class="name">semaphore</span>)</div><div class="line">&#125;)</div><div class="line">dispatch_semaphore_wait(<span class="name">semaphore</span>, DISPATCH_TIME_FOREVER)</div><div class="line">//the expensive asynchronous work is now done</div></pre></td></tr></table></figure>
<ul>
<li>调用<code>dispatch_semaphore_wait</code>方法会阻塞线程, 直到<code>dispatch_semaphore_signal</code>方法被调用. 这意味着<code>signal</code>必须在不同的线程中被调用, 因为当前线程已经完全被阻塞, 如果调用则会造成死锁. 此外, 我们也不能再主线程中调用<code>wait</code>方法, 而只能在后台线程中调用.</li>
<li>在调用<code>dispatch_semaphore_wait</code>方法时, 我们可以选择任意的超时时间, 但我更倾向于使用<code>DISPATCH_TIME_FOREVER</code>.</li>
<li>看到这里, 我们可能还是不太明确为什么要在已经有block的情况下将其串行化, 但这个机制迟早是有用的. 我最近使用到它的一个情景是, 我需要将一系列异步操作在后台串行执行. 简单抽象来说, 这个情景可以被称作<code>异步串行机制</code>:</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typealias</span> <span class="type">DoneBlock</span> = () -&gt; ()</div><div class="line"><span class="keyword">typealias</span> <span class="type">WorkBlock</span> = (<span class="type">DoneBlock</span>) -&gt; ()</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncSerialWorker</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">let</span> serialQueue = dispatch_queue_create(<span class="string">"com.khanlou.serial.queue"</span>, <span class="type">DISPATCH_QUEUE_SERIAL</span>)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">enqueueWork</span><span class="params">(work: WorkBlock)</span></span> &#123;</div><div class="line">        dispatch_async(serialQueue) &#123;</div><div class="line">            <span class="keyword">let</span> semaphore = dispatch_semaphore_create(<span class="number">0</span>)</div><div class="line">            work(&#123;</div><div class="line">                dispatch_semaphore_signal(semaphore)</div><div class="line">            &#125;)</div><div class="line">            dispatch_semaphore_wait(semaphore, <span class="type">DISPATCH_TIME_FOREVER</span>)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>我们可以看到, 在这个简单的类中, 我们创建了一个串行队列, 并且允许使用一个block将要执行的代码入队. 同时, 这个<code>WorkBlock</code>在执行完毕后提供了一个<code>DoneBlock</code>作为返回值, 而这个<code>DoneBlock</code>则会触发<code>信号量</code>, 来使得这个串行队列得以继续执行.</li>
</ul>
<h3 id="限制并发block的数量"><a href="#限制并发block的数量" class="headerlink" title="限制并发block的数量"></a>限制并发block的数量</h3><blockquote>
<p>在之前的例子中, 信号量仅仅作为简单的标记进行使用, 但实际上它也可以作为有限资源的计数器来使用. 如果你仅仅希望针对某一特定的资源服务开启指定数量的网络连接, 你可以参考下面的代码: </p>
</blockquote>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LimitedWorker</span> &#123;</span></div><div class="line">	private <span class="keyword">let</span> serialQueue = dispatch_queue_create(<span class="string">"com.khanlou.serial.queue"</span>, DISPATCH_QUEUE_SERIAL)</div><div class="line">	private <span class="keyword">let</span> concurrentQueue = dispatch_queue_create(<span class="string">"com.khanlou.concurrent.queue"</span>, DISPATCH_QUEUE_CONCURRENT)</div><div class="line">	private <span class="keyword">let</span> semaphore: dispatch_semaphore_t</div><div class="line">		</div><div class="line">	init(limit: Int) &#123;</div><div class="line">        semaphone = dispatch_semaphore_create(limit)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    func enqueue<span class="function"><span class="params">(task: () -&gt; ())</span> &#123;</span></div><div class="line">        <span class="title">dispatch_async</span><span class="params">(serialQueue)</span> &#123;</div><div class="line">            <span class="title">dispatch_semaphore_wait</span><span class="params">(self.semaphore, DISPATCH_TIME_FOREVER)</span></div><div class="line">            <span class="title">dispatch_async</span><span class="params">(self.concurrentQueue)</span> &#123;</div><div class="line">                <span class="title">task</span><span class="params">()</span></div><div class="line">                <span class="title">dispatch_semaphore_signal</span><span class="params">(self.semaphore)</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>这一段代码是参考自苹果官方的 <a href="https://developer.apple.com/library/content/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html#//apple_ref/doc/uid/TP40008091-CH102-SW24" target="_blank" rel="external">Concurrency Programming Guide</a>. 而其中的解释要比我清晰一些: </p>
<blockquote>
<p>当我们创建信号量时, 可以针对特定的资源指定可用数量. 该变量可以在初始化信号量的时候进行赋值. 每次在我们等待(调用<code>wait</code>)的时候, <code>dispatch_semaphore_wait</code>方法会将该变量自减1. 如果自减后的结果为负数, 则该方法内部会通知内核阻塞该线程. 换句话说, <code>dispatch_semaphore_signal</code>方法则会将该变量自增1, 以表示该资源已经被释放, 可以使用. 如果此时有任务被阻塞, 且正在等待可用资源的话, 其中之一就会被释放开并被执行.</p>
</blockquote>
<ul>
<li>这个机制比较类似于<code>NSOperationQueue</code>中的<code>maxConcurrentOperationCount</code>属性. 如果我们使用了 GCD 原生的队列取代了<code>NSOperationQueue</code>的话, 则可以使用信号量控制同时执行的block数量.</li>
<li><p>感谢 <a href="http://dx13.co.uk/articles/2016/6/4/limiting-concurrent-execution-using-gcd.html" target="_blank" rel="external">Mike Rhodes</a> 的提醒, 这段代码可以被一个 <a href="https://gist.github.com/khanlou/c5664183cfa5505a4eb011656c2c0e46" target="_blank" rel="external">之前的版本</a> 优化. 他写道: </p>
<blockquote>
<p>我们使用并发队列来执行用户的任务, 并在该队列中执行 GCD 允许我们执行的数量的任务. 其中的关键在于第二个 GCD 队列. 该队列是一个串行队列, 对于之前的并发队列来说, 其扮演了一个守门员的角色. 我们在这个串行队列中等待信号量的发出, 这意味着当并发队列中的任务数量达到最大后, 我们也只有一个被阻塞的线程. 而其它被入队的任务则会在串行队列内部等待执行, 并且不会导致新线程被开启.</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p>未完待续.</p>
]]></content>
    </entry>
    
  
  
</search>
